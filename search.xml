<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang 78 語法篇 - interface</title>
    <url>/2020/07/03/golang78syntax/</url>
    <content><![CDATA[<p>Interface 可以說是 golang 的精髓之一。golang interface 特殊的語法以及概念也是工程師常常犯錯的地方。此題只是用來釐清自己的概念。</p>
<h1 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h1><p>請問以下程式輸出結果為何</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;</span><br><span class="line">    val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">F</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IF <span class="keyword">interface</span> &#123;</span><br><span class="line">	F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitType</span><span class="params">()</span> <span class="title">S</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitPointer</span><span class="params">()</span> *<span class="title">S</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitEfaceType</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitEfacePointer</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">var</span> s *S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitIfaceType</span><span class="params">()</span> <span class="title">IF</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitIfacePointer</span><span class="params">()</span> <span class="title">IF</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// fmt.Println(InitType() == nil) // type mismatch</span></span><br><span class="line">	fmt.Println(InitPointer() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitEfaceType() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitEfacePointer() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitIfaceType() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitIfacePointer() == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <a id="more"></a>

<h1 id="回歸基本"><a href="#回歸基本" class="headerlink" title="回歸基本"></a>回歸基本</h1><p>在回答問題之前先複習什麼是 <code>Interface Satisfaction</code> 和 <code>Interface Values</code> ，分別在 The Go Programming Language 章節 7.3 和 7.5。</p>
<h2 id="Interface-Satisfaction"><a href="#Interface-Satisfaction" class="headerlink" title="Interface Satisfaction"></a>Interface Satisfaction</h2><p>直接給出書上的解釋，這兩段句子及範例程式已經淺顯易懂，不多作解釋:</p>
<p>A type <code>satisfies</code> an interface if it possesses all the methods the interface requires.</p>
<p>The assignability rule for interfaces is very simple: an expression may be assigned to an interface only if its type satisfies the interface.</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package io</span></span><br><span class="line"><span class="comment">type Writer interface &#123;</span></span><br><span class="line"><span class="comment">    Write(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout           <span class="comment">// OK: *os.File has Write method</span></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)   <span class="comment">// OK: *bytes.Buffer has Write method</span></span><br><span class="line">w = time.Second         <span class="comment">// compile error: time.Duration lacks Write method</span></span><br></pre></td></tr></table></figure>

<h2 id="Interface-Values"><a href="#Interface-Values" class="headerlink" title="Interface Values"></a>Interface Values</h2><p>The Go Programming Language 7.5 第一句開門見山地馬上給出概念:</p>
<p>Conceptually, a value of an interface type, or <code>interface value</code> has two components, a concrete type and a value of that type . These are called the interface’s <code>dynamic type</code> and <code>dynamic value</code>.</p>
<p>並且用一個例子做出了很棒的解釋:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<img data-src="/2020/07/03/golang78syntax/golang78syntax_1.jpg" class="" title="line1 - line4">

<p>另一個例子:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line"><span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">w = buf</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%v %T\n"</span>, w, w) <span class="comment">// &lt;nil&gt;  *bytes.Buffer</span></span><br><span class="line"><span class="keyword">if</span> w != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"w not nil"</span>) <span class="comment">// This line will be executed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若 <code>w != nil</code> 要成立則 <code>dynamic type</code> 和 <code>dynamic value</code> 皆為 <code>non-nil</code> 才會成立。<br>因為 w 的 dynamic value 是 <code>*bytes.Buffer</code> 不為 <code>nil</code> 所以 <code>w != nil</code> 就會成立。</p>
<img data-src="/2020/07/03/golang78syntax/golang78syntax_2.jpg" class="">

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>題目的 Line 43, 44 難度不高，直接跳過<br>剩下的看下圖</p>
<img data-src="/2020/07/03/golang78syntax/golang78syntax_3.jpg" class="">

<p>Line 50 牽扯到了 <code>method set</code> 的細節，留著下篇解釋，可以參考 Reference 1, 2</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener">https://golang.org/ref/spec#Method_sets</a></li>
<li><a href="https://stackoverflow.com/questions/33587227/method-sets-pointer-vs-value-receiver" target="_blank" rel="noopener">https://stackoverflow.com/questions/33587227/method-sets-pointer-vs-value-receiver</a></li>
</ol>
]]></content>
      <categories>
        <category>golang78 syntax series</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 開發環境 - 使用 neovim</title>
    <url>/2020/09/03/go_neovim_env/</url>
    <content><![CDATA[<img data-src="/2020/09/03/go_neovim_env/cover.png" class="">

<h1 id="你確定要用-neovim-開發-golang"><a href="#你確定要用-neovim-開發-golang" class="headerlink" title="你確定要用 neovim 開發 golang?"></a>你確定要用 neovim 開發 golang?</h1><p>現在是 vscode 稱霸天下的時代，理所當然的 (neo)vim 也常常被拿來 vscode 比較，vscode 內建整合了 git、debugger、自動補全引擎、terminal、extension manager，另外 Golang 在 vscode 上的 extension 支援相當良好: 包括跳轉到定義 (go to definition)、重新命名 (rename)、跳轉到型態定義 (go to type definition)⋯⋯ 一堆細節功能，近期由於 google golang team 接手 go 語言的 vscode extension，相信使用 vscode 開發是不錯的選擇。</p>
<p> (neo)vim 當然也能達到 vscode 的類似功能，但是必須花時間設定調教，在 vscode 問世之前我會推薦 (Neo)vim 給我的朋友，vscode 問世之後我就開始推薦 vscode。</p>
<blockquote>
<p>本文給那些本來就在 (neo)vim 裡打滾的人，但對 go 語言設定不熟的人，<br>如果你是一張白紙，而且沒有被虐的癖好，我建議選擇 vscode，可以用較少的時間進入到寫程式的環節，而不是一直在花時間在設定，這篇文你也沒必要看下去。</p>
</blockquote>
<h1 id="預備動作"><a href="#預備動作" class="headerlink" title="預備動作"></a>預備動作</h1><p>Must have</p>
<ul>
<li>你應該先安裝好 neovim nightly 版本，<code>brew install neovim --HEAD</code></li>
<li>你應該要知道怎麼使用 vim-plug，至少要知道 <code>:PlugInstall</code></li>
<li>你應該先把 go 語言環境安裝好</li>
</ul>
<p>Nice to have</p>
<ul>
<li>你知道 <code>:checkhealth</code> 和 <code>:UpdateRemotePlugin</code></li>
<li>你熟悉 <code>:help</code> 的使用方式，這裡有一篇好文：<a href="https://vim.fandom.com/wiki/Learn_to_use_help" target="_blank" rel="noopener">Learn to use help</a></li>
</ul>
<h1 id="開發環境基本功能"><a href="#開發環境基本功能" class="headerlink" title="開發環境基本功能"></a>開發環境基本功能</h1><p>一個好用的 Editor 我認為應該包含以下幾點基本功能:</p>
<ul>
<li>Auto completion - 好的自動補全引擎</li>
<li>File manager - 可以在側邊欄看到專案的結構</li>
<li>Real time linter - 在寫 code 犯錯的同時，有一些提示 (也就是 diagnostic 功能)</li>
<li>Background compile - 編譯的同時不應該卡住整個 Editor，要讓使用者能做其他事情</li>
<li>Code navigation: 包含跳轉到定義，跳轉到型態定義，或是當一個檔案寫得很長的時候，怎麼綜觀全局</li>
</ul>
<p>以下我將會介紹我使用的 Plugin，達到我上述所提到的功能。<br>以下使用的皆是 Neovim nightly 版本，使用 stable 是沒有官方 LSP 支援的。</p>
<p>Note：neovim 是由 vim 所 fork 出來的，差異介紹請看<a href="https://kerol2r20.github.io/post/2017-10-29-neovim-introdunction/" target="_blank" rel="noopener">這篇</a>，某些 Plugin 不會同時相容於兩者，我接會標明。</p>
 <a id="more"></a>

<h1 id="File-explorer-defx-nvim"><a href="#File-explorer-defx-nvim" class="headerlink" title="File explorer (defx.nvim)"></a>File explorer (defx.nvim)</h1><img data-src="/2020/09/03/go_neovim_env/defx.png" class="">

<p>為什麼不用老牌的 nerdtree 就好，要使用別的 file explorer，<br>沒辦法 nerdtree 就是慢，只要專案稍微有一點規模，就會有明顯的卡頓。</p>
<p>defx 由 python3 寫成，是一個需要高度手動設定的 file explorer，不像 nerdtree 幾乎可以開箱及用，在設定時一定得查看 defx 的 help 文件，裡頭有相當多設定範例。</p>
<p>為了讓 neovim 知道 python3 在哪，將此行寫入 vimrc：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:python3_host_prog</span> = <span class="string">'/path/to/python3'</span></span><br></pre></td></tr></table></figure>
<p>設定完此行之行 執行 <code>:checkhealth</code>，neovim 就會開始查看有沒有抓到 python3</p>
<p>安裝</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'Shougo/defx.nvim'</span></span><br></pre></td></tr></table></figure>
<p>安裝完後執行 <code>:UpdateRemotePlugins</code></p>
<p>使用 F4 映射到 defx</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;F4&gt;</span> <span class="symbol">&lt;cmd&gt;</span>Defx -<span class="keyword">buffer</span>-name=<span class="string">"defx"</span><span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<p>外觀設定</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> defx#custom#column(<span class="string">'icon'</span>, &#123;</span><br><span class="line">            \ <span class="string">'directory_icon'</span>: <span class="string">'▸'</span>,</span><br><span class="line">            \ <span class="string">'opened_icon'</span>: <span class="string">'▾'</span>,</span><br><span class="line">            \ <span class="string">'root_icon'</span>: <span class="string">'📁 '</span>,</span><br><span class="line">            \ &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> defx#custom#column(<span class="string">'filename'</span>, &#123;</span><br><span class="line">            \ <span class="string">'min_width'</span>: <span class="number">128</span>,</span><br><span class="line">            \ <span class="string">'max_width'</span>: <span class="number">128</span>,</span><br><span class="line">            \ &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> defx#custom#option(<span class="string">'_'</span>, &#123;</span><br><span class="line">            \ <span class="string">'columns'</span>: <span class="string">'mark:indent:icon:filename:type'</span>,</span><br><span class="line">            \ <span class="string">'split'</span>: <span class="string">'vertical'</span>,</span><br><span class="line">            \ <span class="string">'winwidth'</span>: <span class="number">35</span>,</span><br><span class="line">            \ <span class="string">'direction'</span>: <span class="string">'topleft'</span>,</span><br><span class="line">            \ <span class="string">'resume'</span>: <span class="variable">v:false</span>,</span><br><span class="line">            \ <span class="string">'toggle'</span>: <span class="variable">v:true</span></span><br><span class="line">            \ &#125;)</span><br></pre></td></tr></table></figure>

<p>使用 enter 打開或關閉資料夾：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;buffer&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;CR&gt;</span></span><br><span class="line">            \ defx#is_directory() ?</span><br><span class="line">            \ defx#do_action(<span class="string">'open_or_close_tree'</span>) :</span><br><span class="line">            \ defx#do_action(<span class="string">'drop'</span>)</span><br></pre></td></tr></table></figure>


<p>因為 defx 的高度彈性，以及舊有的 nerdtree使用習慣，所以我就把 defx 的 key mapping 設定成類似 nerdtree，這裡就只做基本設定，以後有空會多開一篇詳細講 defx 設定，如果有興趣請參考<a href="https://github.com/amikai/nvimrc/blob/46d4c73f9e/config/defx.vim" target="_blank" rel="noopener">我的設定</a> </p>
<p>Note: defx (neovim only)</p>
<p>類似 Plugin: <a href="https://github.com/preservim/nerdtree" target="_blank" rel="noopener">nerdtree</a> (vim and neovim), <a href="https://github.com/justinmk/vim-dirvish" target="_blank" rel="noopener">vim-dirvish</a> (vim and neovim)</p>
<h1 id="Auto-completion-completion-nvim-amp-diagnostic-diagnostic-nvim"><a href="#Auto-completion-completion-nvim-amp-diagnostic-diagnostic-nvim" class="headerlink" title="Auto completion (completion-nvim) &amp; diagnostic (diagnostic-nvim)"></a>Auto completion (completion-nvim) &amp; diagnostic (diagnostic-nvim)</h1><p>completion-nvim 和 diagnostic-nvim 都是基於 nvim-lspconfig 的 Plugin，<br>可以把 nvim-lspconfig 當成和 language server 溝通的基礎設施，Golang 預設的 language server 當然就是 gopls 啦</p>
<p>安裝</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'neovim/nvim-lspconfig'</span></span><br><span class="line">Plug <span class="string">'nvim-lua/diagnostic-nvim'</span></span><br><span class="line">Plug <span class="string">'nvim-lua/completion-nvim'</span></span><br></pre></td></tr></table></figure>

<p>在 lsp client 時，啟動 <code>completion-nvim</code> 和 <code>diagnostic-nvim</code>：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">lua &lt;&lt; EOF</span><br><span class="line">    <span class="keyword">local</span> nvim_lsp = <span class="built_in">require</span><span class="string">'nvim_lsp'</span></span><br><span class="line">    <span class="keyword">local</span> on_attach_vim = <span class="function"><span class="keyword">function</span><span class="params">(client, bufnr)</span></span></span><br><span class="line">        <span class="built_in">require</span><span class="string">'completion'</span>.on_attach(client, bufnr)</span><br><span class="line">        <span class="built_in">require</span><span class="string">'diagnostic'</span>.on_attach(client, bufnr)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    nvim_lsp.gopls.setup&#123;</span><br><span class="line">        on_attach=on_attach_vim</span><br><span class="line">    &#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><code>diagnostic-nvim</code> 範例設定：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> sign_define(<span class="string">"LspDiagnosticsErrorSign"</span>, &#123;<span class="string">"text"</span> : <span class="string">"E"</span>, <span class="string">"texthl"</span> : <span class="string">"LspDiagnosticsError"</span>&#125;)</span><br><span class="line"><span class="keyword">call</span> sign_define(<span class="string">"LspDiagnosticsWarningSign"</span>, &#123;<span class="string">"text"</span> : <span class="string">"W"</span>, <span class="string">"texthl"</span> : <span class="string">"LspDiagnosticsWarning"</span>&#125;)</span><br><span class="line"><span class="keyword">call</span> sign_define(<span class="string">"LspDiagnosticsInformationSign"</span>, &#123;<span class="string">"text"</span> : <span class="string">"I"</span>, <span class="string">"texthl"</span> : <span class="string">"LspDiagnosticsInformation"</span>&#125;)</span><br><span class="line"><span class="keyword">call</span> sign_define(<span class="string">"LspDiagnosticsHintSign"</span>, &#123;<span class="string">"text"</span> : <span class="string">"H"</span>, <span class="string">"texthl"</span> : <span class="string">"LspDiagnosticsHint"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:diagnostic_show_sign</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:diagnostic_enable_virtual_text</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:diagnostic_insert_delay</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:diagnostic_virtual_text_prefix</span> = <span class="string">'&lt;'</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<img data-src="/2020/09/03/go_neovim_env/diagnostic_demo.gif" class="">

<p>如果覺得字還沒打完就有警告很煩，可以改變此選項 <code>let g:diagnostic_insert_delay = 1</code>，則會在進入 normal mode 時進行警告。</p>
<p><code>completion-nvim</code> 範例設定：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:completion_chain_complete_list</span> = [</span><br><span class="line">            \&#123;<span class="string">'complete_items'</span>: [<span class="string">'lsp'</span>]&#125;,</span><br><span class="line">            \]</span><br></pre></td></tr></table></figure>
<p>效果</p>
<img data-src="/2020/09/03/go_neovim_env/completion_demo.gif" class="">

<p>Note: <code>nvim-lspconfig</code>, <code>completion-nvim</code>, <code>diagnostic-nvim</code> 皆不相容 vim</p>
<p>LSP 相關 Plugin： <a href="https://github.com/prabirshrestha/vim-lsp" target="_blank" rel="noopener">vim-lsp</a> (vim only), <a href="https://github.com/autozimu/LanguageClient-neovim" target="_blank" rel="noopener">LanguageClient-neovim</a> (neovim only)</p>
<p>Completion 相關 Plugin： <a href="https://github.com/ncm2/ncm2" target="_blank" rel="noopener">ncm2</a> (vim8 and neovim), <a href="https://github.com/Shougo/deoplete.nvim" target="_blank" rel="noopener">deoplete.nvim</a> (vim8 and neovim)</p>
<p>Diagnostic 相關 Plugin: <a href="https://github.com/neomake/neomake" target="_blank" rel="noopener">neomake</a> (neovim and vim8), <a href="https://github.com/dense-analysis/ale" target="_blank" rel="noopener">ale</a> (neovim and vim8)</p>
<blockquote>
<p>看了 completion-nvim 的 contribution 大部分是由 haorenW1025 大大所寫，帳號掛 NTU，台灣人寫的套件還不支持一波</p>
</blockquote>
<h1 id="Code-Outline-tagbar"><a href="#Code-Outline-tagbar" class="headerlink" title="Code Outline (tagbar)"></a>Code Outline (tagbar)</h1><img data-src="/2020/09/03/go_neovim_env/tagbar_demo.png" class="">

<p>當 code 越寫越多，一個 file 越長越大，一個 file 超過 1000 行，或超過 15 個 function，就需要一個綜觀全局的 Plugin，這當然就需要交給 <code>tagbar</code> 了。</p>
<p>另外一種情境，當你不熟你手上的這份專案時，用 <code>tagbar</code> 先進行大綱式的觀察，是再好不過的方式了</p>
<p>首先先安裝 <a href="https://github.com/jstemmer/gotags" target="_blank" rel="noopener">gotags</a>, gotags 在 Readme 上都寫好怎麼設定了。</p>
<p>安裝 Tagbar:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'majutsushi/tagbar'</span></span><br></pre></td></tr></table></figure>
<p>gotags 及 tagbar 設定：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:tagbar_type_go</span> = &#123;</span><br><span class="line">            \ <span class="string">'ctagstype'</span> : <span class="string">'go'</span>,</span><br><span class="line">            \ <span class="string">'kinds'</span>     : [</span><br><span class="line">            \ <span class="string">'p:package'</span>,</span><br><span class="line">            \ <span class="string">'i:imports:1'</span>,</span><br><span class="line">            \ <span class="string">'c:constants'</span>,</span><br><span class="line">            \ <span class="string">'v:variables'</span>,</span><br><span class="line">            \ <span class="string">'t:types'</span>,</span><br><span class="line">            \ <span class="string">'n:interfaces'</span>,</span><br><span class="line">            \ <span class="string">'w:fields'</span>,</span><br><span class="line">            \ <span class="string">'e:embedded'</span>,</span><br><span class="line">            \ <span class="string">'m:methods'</span>,</span><br><span class="line">            \ <span class="string">'r:constructor'</span>,</span><br><span class="line">            \ <span class="string">'f:functions'</span></span><br><span class="line">            \ ],</span><br><span class="line">            \ <span class="string">'sro'</span> : <span class="string">'.'</span>,</span><br><span class="line">            \ <span class="string">'kind2scope'</span> : &#123;</span><br><span class="line">            \ <span class="string">'t'</span> : <span class="string">'ctype'</span>,</span><br><span class="line">            \ <span class="string">'n'</span> : <span class="string">'ntype'</span></span><br><span class="line">            \ &#125;,</span><br><span class="line">            \ <span class="string">'scope2kind'</span> : &#123;</span><br><span class="line">            \ <span class="string">'ctype'</span> : <span class="string">'t'</span>,</span><br><span class="line">            \ <span class="string">'ntype'</span> : <span class="string">'n'</span></span><br><span class="line">            \ &#125;,</span><br><span class="line">            \ <span class="string">'ctagsbin'</span>  : <span class="string">'gotags'</span>,</span><br><span class="line">            \ <span class="string">'ctagsargs'</span> : <span class="string">'-sort -silent'</span></span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure>


<h1 id="Go-development-plugin-vim-go"><a href="#Go-development-plugin-vim-go" class="headerlink" title="Go development plugin (vim-go)"></a>Go development plugin (vim-go)</h1><p>Golang 在 vim 的開發中，不可能不提 <code>vim-go</code> 了，應該也是我在 vim plugin 看過支援完整的開發工具之一了，vim-go 設定眾多，我只挑出了我覺得最有用的幾個出來談。</p>
<p>安裝</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'fatih/vim-go'</span>,&#123;<span class="string">'for'</span>:<span class="string">'go'</span>, <span class="string">'do'</span>: <span class="string">':GoUpdateBinaries'</span>&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/golangci/golangci-lint" target="_blank" rel="noopener">golangci-lint</a> 是把不一樣的 go 語言 linter 集合起來成一包，在 teminal 打 <code>golangci-lint linters</code> 就會列出一堆 linter，挑選自己想要的 linter 放入 <code>g:go_metalinter_enabled</code> 陣列裡。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:go_metalinter_command</span> = <span class="string">"golangci-lint"</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:go_metalinter_enabled</span> = [<span class="string">'vet'</span>, <span class="string">'errcheck'</span>, <span class="string">'staticcheck'</span>, <span class="string">'gosimple'</span>]</span><br></pre></td></tr></table></figure>
<p>使用 <code>:GoMetaLinter</code> 開始對專案進行檢查。</p>
<p>當然 code 越大或是 linter 放得越多檢查越慢，所以我通常寫到一個段落才下此命令，linter 檢查完後 quickfix list 則會跳出，請看demo：</p>
<img data-src="/2020/09/03/go_neovim_env/golangci_lint_demo.gif" class="">

<p>code navigation 設定，不使用 <code>vim-go</code> 預設的 key mapping，使用自己習慣的方式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:go_def_mapping_enabled</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> gd <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-def)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> gD <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-describe)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> gR <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-<span class="built_in">rename</span>)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="keyword">gr</span> <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-referrers)</span><br></pre></td></tr></table></figure>

<p>最屌的是 vim-go 能直接跑 Testing (<code>:GoTest</code>), Debugger (<code>:GoDebugStart</code>), Run (<code>:GoRun</code>), Build (<code>:GoBuild</code>)</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;f4&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-test)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;f5&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-build)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;f6&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-run)</span><br></pre></td></tr></table></figure>

<p><code>:GoTest</code> demo：</p>
<img data-src="/2020/09/03/go_neovim_env/go_test_demo.gif" class="">

<p>vim-go 設定一定要看過 <a href="https://github.com/fatih/vim-go-tutorial" target="_blank" rel="noopener">vim-go-tutorial</a>，由 vim-go 作者提供的設定教學。</p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>如果要一個適合自己的 (neo)vim 環境，當然這篇文章只是冰山一角而已。這裡提到的 Plugin，每一個都可以開一篇文章來介紹，所以每一個 Plugin 我盡量用最簡單的範例設定，展現它的功能和精髓。另外還有 fuzzy finder, auto pair, indent line guide, snippet ..等 Plugin, 還沒提到，之後會分好幾篇文章來寫。</p>
<p>在配置設定的一開始，盡量先去抄別人的，直接看看抄了設定會發生什麼效果， 或是使用 <code>:help</code> 查詢看看。</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h1><p>要去哪裡查到別人的 vim 設定？<br>在 github 上查詢關鍵字：dotfile, dotfiles, vimrc, vim-config, nvimrc 等等的字。<br>這裡我就提供兩個大神的 vim 設定：</p>
<ul>
<li><a href="https://github.com/Shougo/shougo-s-github" target="_blank" rel="noopener">https://github.com/Shougo/shougo-s-github</a></li>
<li><a href="https://github.com/rafi/vim-config" target="_blank" rel="noopener">https://github.com/rafi/vim-config</a></li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://github.com/neovim/nvim-lspconfig" target="_blank" rel="noopener">https://github.com/neovim/nvim-lspconfig</a></li>
<li><a href="https://github.com/fatih/vim-go-tutorial" target="_blank" rel="noopener">https://github.com/fatih/vim-go-tutorial</a></li>
</ul>
]]></content>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
      </tags>
  </entry>
  <entry>
    <title>在 (neo)vim 裡 C 語言程式碼導覽技巧</title>
    <url>/2020/11/28/vim-c-env-move/</url>
    <content><![CDATA[<p>現代的專案開發，很少在從無到有打造，大部分都是基於現有的程式之上繼續開發或維護，進入專案之後，通常第一件事就是大量閱讀程式碼理清專案的整個脈絡，才開始著手寫 code，所以好的程式碼導覽技巧將會帶你上天堂。</p>
<p>我將大部分的程式碼導覽情境大致拆成了三種情況：</p>
<ul>
<li>基本的跳轉：<ul>
<li><code>#if</code> <code>#endif</code> 中間的程式碼太長，想要跳轉到成對的 <code>#if</code> <code>#endif</code> </li>
<li>cursor 在 {…} block 裡， 這個 block 又臭又長，想快速跳轉 block 的開頭和結尾</li>
<li>註解長篇大論，想快速跳到註解的開頭或結尾</li>
</ul>
</li>
<li>尋找專案下檔案 (可透過設定 path option 解決)<ul>
<li>跳轉到標頭檔</li>
<li>跳轉到指定檔案</li>
</ul>
</li>
<li>使用 source code tagging system 快速挑轉到 function 定義及特定 symbol 等等：<br>專案相當大的時候，source code tagging system 相當好用，可以快速找到定位，也不會花掉太多的資源，比起 LSP 的跳轉定義，是較輕量的選擇。</li>
</ul>
<p>本篇依據上述三種情境，一一講述。<br> <a id="more"></a></p>
<h1 id="常用跳轉操作"><a href="#常用跳轉操作" class="headerlink" title="常用跳轉操作"></a>常用跳轉操作</h1><ul>
<li><p><code>%</code></p>
<ul>
<li>跳到成對的括號</li>
<li>如果註解是 <code>/*...*/</code>，跳到成對的註解符號</li>
<li>在成對的 <code>#if</code>, <code>#ifdef</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code> 之中跳轉，這相當重要，如果 code 很長, if else macro 又是巢狀的，這招可以讓你少迷路好幾次</li>
</ul>
</li>
<li><p><code>[{</code> <code>]}</code></p>
<ul>
<li><code>[{</code>：若 cursor 在 {…} 區塊中，跳到此區塊的 {</li>
<li><code>]}</code>：若 cursor 在 {…} 區塊中，跳到此區塊的 }</li>
</ul>
</li>
<li><p><code>[*</code> <code>]*</code></p>
<ul>
<li><code>[*</code>：找到上一個 /*</li>
<li><code>]*</code>：找到下一個 */</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>[#</code> <code>]#</code><br>  用法和 <code>[{</code> <code>]}</code> 類似，但是針對的是 <code>#</code><br>  在 line2 區塊 <code>[{</code> 跳到 line1, <code>]}</code> 跳到 line3<br>  在 line4 區塊 <code>[{</code> 跳到 line3, <code>]}</code> 跳到 line5<br>  在 line6 區塊 <code>[{</code> 跳到 line5, <code>]}</code> 跳到 line7</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST</span></span><br><span class="line"><span class="comment">// line2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> TEST2</span></span><br><span class="line"><span class="comment">// line4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// line6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>  若 cursor 在 #else…#endif 區塊中，跳到 #else</p>
</li>
</ul>
<h1 id="透過-path-設定，快速查找相關檔案"><a href="#透過-path-設定，快速查找相關檔案" class="headerlink" title="透過 path 設定，快速查找相關檔案"></a>透過 path 設定，快速查找相關檔案</h1><p>看看以下圖片，將 cursor 移動到程式碼標頭檔的位置 (stdio.h)，按下 <code>gf</code>，bang! 你跳到 stdio.h 標頭檔了</p>
<img data-src="/2020/11/28/vim-c-env-move/vim_gf.gif" class="">


<p>再來看看 <code>:find</code> 指令，我想找出 stdlib.h 標頭檔，使用 <code>:find stdlib.h</code>, 就跳到 stdlib.h 啦</p>
<p>我們來看看 vim 到底怎麼實現這個魔法的：<br>其實 vim 是藉由 <code>path</code> 這個 option 去搜尋的 (詳見 <code>:help &#39;path&#39;</code>)，path 這個值由許多路徑組成並由逗號隔開，在 nix 系統裡 vim 對 path 預設的值是 </p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">.,/usr/include,,</span><br></pre></td></tr></table></figure>
<p>可以看到三個值：</p>
<ul>
<li><code>.</code>： 當前檔案所在的目錄</li>
<li><code>/usr/include</code>： 很顯然找到 <code>gf</code> 找到的 stdio.h 和 <code>:find</code> 找到的 stdlib.h 是由這個目錄找出來的</li>
<li>empty string：工作目錄 (current work directory, 通常是 vim 開啟的位置，如果你沒用 <code>:cd</code> 的話)</li>
</ul>
<p>所以可以把自己常用的標頭檔所在目錄加入 path ！ 舉個例子 <code>/usr/local/include</code> 也是很常放標頭檔的路徑，所以我把它加入到 path</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> path+=/usr/local/include</span><br></pre></td></tr></table></figure>


<p>註: <code>.</code> 和 empty string 的差別請看：<a href="https://vi.stackexchange.com/questions/5998/is-vims-default-path-option-redundant" target="_blank" rel="noopener">is-vims-default-path-option-redundant</a></p>
<p><code>**</code> 算是一個蠻好用的值，它會對路徑做 recursive 的解析，你可能會使用到它，詳細的規則可以看 <code>:help starstar</code></p>
<h1 id="Source-code-tagging-system-和-vim"><a href="#Source-code-tagging-system-和-vim" class="headerlink" title="Source code tagging system 和 vim"></a>Source code tagging system 和 vim</h1><p>2020 年 Linux kernel 原始碼規模已經達到 2780 萬行，規模如此之龐大，Linux 的程式開發人員到底是怎麼開發的，隨便想找一個 function 定義都相當吃力，總不能用 grep 慢慢去找吧!這時候 source code tagging system 就派上用場了，它可以對專案所有的 symbol 產生索引檔，需要查找目標時就藉由這些索引檔快速查找位置。概念其實就是字典的索引，字典這麼大一本不會有人從頭掃到尾，都是直接翻到字典最後面的索引快速找到目標。</p>
<p>這些 source code tagging system，通常會產生索引檔並且提供一個介面，讓編輯器使用它們快速在程式碼內定位。</p>
<p>接下來將逐一介紹 cscope, gtags, ctags 等等三個 source code tagging system 在 vim 裡的基本使用方式。</p>
<h1 id="Cscope"><a href="#Cscope" class="headerlink" title="Cscope"></a>Cscope</h1><h2 id="Cscope-簡介"><a href="#Cscope-簡介" class="headerlink" title="Cscope 簡介"></a>Cscope 簡介</h2><p>cscope 官網聲稱可以做到以下事情：</p>
<ul>
<li>查詢所有使用到這個 symbol 的地方</li>
<li>查詢全域變數</li>
<li>查詢 function 在哪被呼叫</li>
<li>查詢這個 function 呼叫了誰</li>
<li>使用字串查詢找到目標</li>
<li>使用 egrep pattern 尋找目標</li>
<li>快速尋找專案下檔案</li>
<li>查看哪個檔案 include 當前檔案</li>
</ul>
<p>cscope 指令常用選項</p>
<ul>
<li>b：只產生索引檔案，不進入互動查詢介面</li>
<li>q：產生 cscope.in.out 和 cscope.po.out文件，加快 cscope 的索引速度 </li>
<li>k：產生索引檔案时，不搜尋 /usr/include</li>
<li>R：遞迴搜尋子目錄</li>
</ul>
<h2 id="Cscope-和-vim"><a href="#Cscope-和-vim" class="headerlink" title="Cscope 和 vim"></a>Cscope 和 vim</h2><p>在專案目錄產生索引檔案:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cscope -bkqR</span><br></pre></td></tr></table></figure>
<p>會產生三個檔案 <code>cscope.in.out</code> <code>cscope.out</code> <code>cscope.po.out</code></p>
<p>進入 vim 之後可以透過 <code>cs</code> 查看 cscope 在 vim 裡的使用方式</p>
<img data-src="/2020/11/28/vim-c-env-move/vim_cscope.png" class="">


<p>讓 vim 知道 cscope 的路徑</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> cscopeprg=/path/<span class="keyword">to</span>/<span class="keyword">cscope</span></span><br></pre></td></tr></table></figure>

<p>指定 cscope 索引檔案，讓 vim 知道要用哪個索引檔案查詢：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">cs</span> <span class="built_in">add</span> <span class="keyword">cscope</span>.out</span><br></pre></td></tr></table></figure>

<p>接下來就可以使用以下方式查詢 (xxx 為想搜尋的目標):</p>
<ul>
<li><code>:cs find a xxx</code> 查尋 xxx 被賦值的地方</li>
<li><code>:cs find c xxx</code> 查尋所有呼叫 xxx function 的地方</li>
<li><code>:cs find d xxx</code> 查尋 xxx function 呼叫的所有函數</li>
<li><code>:cs find e xxx</code> 使用 egrep pattern 查詢</li>
<li><code>:cs find f xxx</code> 找出 xxx 檔案在哪裡</li>
<li><code>:cs find g xxx</code> 查尋 xxx 所定義的地方 (通常最常用的是這個)</li>
<li><code>:cs find i xxx</code> 查尋所有 inlcude xxx 檔案的地方</li>
<li><code>:cs find s xxx</code> 查尋所有 xxx symbol 出現的地方</li>
<li><code>:cs find t xxx</code> 查詢 xxx 字串出現的地方，其實搜尋效果就類似 grep </li>
</ul>
<p>記得查詢完的結果可以用 <code>:cw</code>, <code>:copen</code> 在 quickfix window 列出：</p>
<h1 id="GNU-GLOBAL-gtags"><a href="#GNU-GLOBAL-gtags" class="headerlink" title="GNU GLOBAL (gtags)"></a>GNU GLOBAL (gtags)</h1><p>由 GNU GLOBAL 由 GNU 所開發的 soure code tagging system，本身支持四種語言，透過 Pygments 和 Universal Ctags 的 parser 可以支持其他 25 種語言，支援 incremental update，原始碼更動後，只會對改變的地方索引，不會重新索引，這對龐大的專案有很大的幫助。另外 gtags 提供了 cscope 相容的互動介面，叫做 gtags-cscope，讓你用起來像 cscope，但背後其實是 gtags 的索引檔案。</p>
<p>在專案目錄產生索引檔案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gtags</span><br></pre></td></tr></table></figure>

<p>讓 vim 知道 gtags-cscope 路徑：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> cscopeprg=/path/<span class="keyword">to</span>/gtsgs-<span class="keyword">cscope</span></span><br></pre></td></tr></table></figure>

<p>指定 gtags 索引檔案，讓 vim 知道要用哪個索引檔案查詢：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">cs</span> <span class="built_in">add</span> GTAGS</span><br></pre></td></tr></table></figure>
<p>借下來就可以用和 cscope 一樣的方式查詢，除了 <code>:cs find d</code>，其他皆支援 </p>
<h1 id="Ctags"><a href="#Ctags" class="headerlink" title="Ctags"></a>Ctags</h1><h2 id="Ctags-簡介"><a href="#Ctags-簡介" class="headerlink" title="Ctags 簡介"></a>Ctags 簡介</h2><p>最早的 Ctag 在 BSD 上實現，版本變革的歷史脈絡我不是相當清楚，查不太到資料。<br>現在普及的版本是 Exuberant Ctags，一開始和 vim 是一包軟體，一起發布，但在 vim6 之後獨立成兩個專案，從這裏可看出它一定和 vim 兼容良好，但此版本在 2009 年之後已不再維護。建議使用Exuberant Ctags 所 fork 的版本 Universal Ctags，目前還在維護和開發當中。</p>
<h2 id="Ctags-和-vim"><a href="#Ctags-和-vim" class="headerlink" title="Ctags 和 vim"></a>Ctags 和 vim</h2><p>在專案下生成索引檔案，可以看到目錄裡有 <code>tags</code> 檔案</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ctags -R *</span><br></pre></td></tr></table></figure>


<p>指定 tags 索引檔案，讓 vim 知道要用哪個索引檔案查詢：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> <span class="keyword">tags</span>=<span class="keyword">tags</span></span><br></pre></td></tr></table></figure>

<p>再來就可以使用:</p>
<ul>
<li><code>Ctrl + ]</code>: 跳到定義，如果有多個匹配則會跳到第一個</li>
<li><code>Ctrl + T</code>: 跳回原本的地方</li>
</ul>
<p>每次用 <code>ctrl + ]</code> 跳轉到定義，vim 就會把這位置推到 tag stack 裡，每次 <code>ctrl + T</code> 跳回原來的地方，vim 就會從 tag stack 裡 pop 位置出來，我們可以使用 <code>:tags</code> 看到 tag stack 裡的內容。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><p><a href="https://dev.to/iggredible/how-to-use-tags-in-vim-to-jump-to-definitions-quickly-2g28" target="_blank" rel="noopener">https://dev.to/iggredible/how-to-use-tags-in-vim-to-jump-to-definitions-quickly-2g28</a></p>
</li>
<li><p><a href="http://praton.me/2020/04/11/Exploring-kernel-code-with-vim.html" target="_blank" rel="noopener">http://praton.me/2020/04/11/Exploring-kernel-code-with-vim.html</a></p>
</li>
<li><p><a href="https://neovim.io/doc/user/usr_29.html" target="_blank" rel="noopener">:help usr_29.txt</a></p>
</li>
<li><p><a href="https://neovim.io/doc/user/usr_30.html" target="_blank" rel="noopener">:help usr_30.txt</a></p>
</li>
<li><p><a href="https://neovim.io/doc/user/tagsrch.html" target="_blank" rel="noopener">:help tagsrch.txt</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊你在 vim 常用的移動方式</title>
    <url>/2020/10/03/vim-commonly-used-motion/</url>
    <content><![CDATA[<p>看下圖，如果想將 <code>&lt;expr&gt;</code> 改成 <code>&lt;leader&gt;</code> 你會怎麼做呢?</p>
<img data-src="/2020/10/03/vim-commonly-used-motion/question.png" class="">

<p>通常我看過的幾種方式如下：</p>
<ol>
<li>使用 <code>j</code> 向下到 97 行，在使用 <code>l</code> 到 target 並且開始編輯，這也是最糟的</li>
<li>target 的行數看起來離 window 中央行很近， 使用 <code>M</code> 跳到 window 中央行，再使用 <code>h</code> <code>j</code> <code>k</code> <code>l</code> 到 target</li>
<li>使用 <code>:set number</code> 列出行號， 按下 <code>97G</code> 到達 97 行， <code>fe</code> <code>;</code> <code>;</code> <code>;</code><br>註: <code>f{char}</code> 找到此行的下一個字母、 <code>;</code> 為重複上一個 <code>f</code> 命令</li>
<li>使用 <code>/</code> 搜尋 <code>expr</code>，在使用 <code>n</code> <code>n</code> <code>n</code> <code>n</code> 到 target</li>
<li><del>使用 <code>set mouse=n</code>，用滑鼠點 target</del><a id="more"></a>

</li>
</ol>
<h1 id="Easymotion"><a href="#Easymotion" class="headerlink" title="Easymotion"></a>Easymotion</h1><p>easymotion 是解決此情境最好的方案之一，它提供了另一種搜尋方式，在搜尋目標之後，會將可能位置的抽換成其他字母，並高亮這些字母，再按下這些字母就可以跳到此位置 (之後簡稱為 label and jump 功能)。 easymotion 的設計就是加強內建的移動指令，只是跳轉到目標的方式變了，所以不需要擔心不會用。</p>
<p>安裝</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'easymotion/vim-easymotion'</span></span><br></pre></td></tr></table></figure>
<p>easymotion 的預設的 key mapping 過多，建議針對所需自行設定就好</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:EasyMotion_do_mapping</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="Easymotion-bd-f"><a href="#Easymotion-bd-f" class="headerlink" title="Easymotion-bd-f"></a>Easymotion-bd-f</h2><p>將 <code>&lt;leader&gt;f</code> 映射到 easymotion-bd-f，很明顯的這個功能就是加強內建 f，差異在於：</p>
<ul>
<li>內建 f 只能單向向前搜尋，而且只能在此行</li>
<li>easymotion-bd-f，bd 代表 bidirectional，也就是雙向搜尋，搜尋結果不限制在此行</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">bd</span>-<span class="keyword">f</span>)</span><br></pre></td></tr></table></figure>
<p>以下圖為使用 easymotion-bd-f 搜尋 e 字母的結果，還記得我們的 target 在 97 行嗎，所以按下 <code>ji</code> 即可跳到 target 了</p>
<img data-src="/2020/10/03/vim-commonly-used-motion/easymotion-f.png" class="" title="easymotion-f">

<h2 id="Easymotion-s2"><a href="#Easymotion-s2" class="headerlink" title="Easymotion-s2"></a>Easymotion-s2</h2><p>使用 easymotion-bd-f 搜尋常常遇到一個問題：只用一個字母搜尋為限制，導致可能的目標太多了，使得整個螢幕很亂。easymotion-s2 使用兩個字母最為限制去搜尋，這種方式看似不起眼，但聰明許多，比起 f 只需多按一個鍵，就能使目標更明確，使螢幕乾淨許多。</p>
<p>將 <code>&lt;leader&gt;s</code> 映射到 easymotion-s2，用法和 easymotion-bd-f 類似只是多了一個字母。<br>經過映射後使用方法為 <code>&lt;leader&gt;s{char}{char}</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>s <span class="symbol">&lt;Plug&gt;</span>(easymotion-s2)</span><br></pre></td></tr></table></figure>
<p>下圖為使用 easymotion-s2 的搜尋 ex 字母的結果，螢幕乾淨很多，在按下 <code>k</code> 到達 target</p>
<img data-src="/2020/10/03/vim-commonly-used-motion/easymotion-s2.png" class="" title="easymotion-s2">

<h1 id="vim-sneak"><a href="#vim-sneak" class="headerlink" title="vim-sneak"></a>vim-sneak</h1><p>easymotion 的功能相當豐富，對於內建常用的移動指令 <code>f</code> <code>F</code> <code>t</code> <code>T</code> <code>w</code> <code>W</code> <code>b</code> <code>B</code> … 都有相對應的擴增功能，還有一堆 fancy 的功能，對我來說幾乎用不到，讓我最常使用的就是 easymotion-s2， 以功能上來看 <a href="https://github.com/justinmk/vim-sneak" target="_blank" rel="noopener">justinmk/vim-sneak</a> 就是簡易版的 easymotion。</p>
<p>安裝 vim-sneak</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'justinmk/vim-sneak'</span></span><br></pre></td></tr></table></figure>

<p>開啟和 easymotion 相同的 label and jump 功能</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:sneak</span>#label = <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p>vim-sneak 提供了四個按鍵 <code>&lt;Plug&gt;Sneak_f</code> <code>&lt;Plug&gt;Sneak_F</code> <code>&lt;Plug&gt;Sneak_t</code> <code>&lt;Plug&gt;Sneak_T</code> 類似於 <code>f</code> <code>F</code> <code>t</code> <code>T</code>，和內建的差異就是這些按鍵搜尋的是兩個字元，和 easymotion-s2 的差異就是沒有雙向搜尋</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> <span class="symbol">&lt;Plug&gt;</span>Sneak_f</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>F <span class="symbol">&lt;Plug&gt;</span>Sneak_F</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>t <span class="symbol">&lt;Plug&gt;</span>Sneak_t</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span>T <span class="symbol">&lt;Plug&gt;</span>Sneak_T</span><br></pre></td></tr></table></figure>
<p>使用的方法和 easymotion-s2 幾乎一樣，就不再做展示。</p>
<p>在 <a href="https://www.reddit.com/r/vim/comments/2ydw6t/large_plugins_vs_small_easymotion_vs_sneak" target="_blank" rel="noopener">Large plugins vs. small (EasyMotion vs. Sneak)</a> 討論串裡，vim-sneak 作者講述了 vim-sneak 和 easymotion 的實作差異，在這就不仔細探討。</p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>本章透過一個簡單的跳轉問題，引出 easymotion plugin 的特色，與其說 easymotion 是一個 plugin，其功能的豐富程度，我更會想把它稱為 motion 框架，最有價值的功能就是 label and jump 的功能，提供了一種全新的跳轉方式，大大的提升了 cursor 的移動效率。</p>
<p>建議先使用 easymotion 使用過一段時間察覺自己的使用習慣 (一定得查看 <code>:help easymotion</code>)，如果嫌棄其臃腫，在針對自己的使用習慣去查找類似的 plugin，以我來說最常使用的就是 easymotion-s2 ，所以我就選用了 <a href="https://github.com/justinmk/vim-sneak" target="_blank" rel="noopener">justinmk/vim-sneak</a>，功能類似 easymotion-s2 但相對於 easymotion 輕量許多。</p>
<p>別忘了，這些功能全都是 motion，是可以搭配 operator 使用的，如果我把問題改成從 cursor 位置一路刪除到 target 的位置，你會怎麼做？</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.reddit.com/r/vim/comments/2ydw6t/large_plugins_vs_small_easymotion_vs_sneak" target="_blank" rel="noopener">Large plugins vs. small (EasyMotion vs. Sneak)</a></li>
<li><a href="https://github.com/justinmk/vim-sneak" target="_blank" rel="noopener">justinmk/vim-sneak</a></li>
<li><a href="https://github.com/yangmillstheory/vim-snipe" target="_blank" rel="noopener">yangmillstheory/vim-snipe</a></li>
</ul>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>誰說不能在 vim 裡編譯，從 :make 到 :Make</title>
    <url>/2020/09/10/vim-make/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回想一下，上一次使用 vim 寫 code 到一個段落要編譯時，你是怎麼做的。</p>
<p>我看到大多數人的方式，就是將 terminal 切成兩塊，一塊寫 code，一塊編譯，若編譯有錯誤，再移動到寫 code 區塊更改。<br>如果使用此方法，當專案有規模時，編譯錯誤一百條，看了編譯錯誤在哪之後，再將編譯錯誤的位置，從專案裡找出來，反覆來回 100 次，直到修正完畢。<br>本文以 C 語言專案為例 (當然不是只有 C 語言才能這樣子幹，可看 Q&amp;A)，聊聊強大的 vim 在這種情境下有什麼好的解決方案。</p>
<img data-src="/2020/09/10/vim-make/tmux_split.png" class="">
 <a id="more"></a>


<h1 id="強大的-make"><a href="#強大的-make" class="headerlink" title="強大的 :make"></a>強大的 <code>:make</code></h1><h2 id="基本款"><a href="#基本款" class="headerlink" title="基本款"></a>基本款</h2><p>此次範例就拿 neovim 來編譯好了，根據官方文件要這樣編譯 <code>make CMAKE_BUILD_TYPE=Release</code>，所以在我在 vim 裡這樣編 <code>:make CMAKE_BUILD_TYPE=Release</code></p>
<p>看起來噴了一點錯誤，案了 <code>enter</code> 似乎之後什麼事都沒發生，回到平常。</p>
<img data-src="/2020/09/10/vim-make/make_cmd.png" class="">

<p>用 <code>:cl</code> 指令，喔幹!不是一點錯誤，是一堆錯誤，沒列出來根本不知道。</p>
<img data-src="/2020/09/10/vim-make/clist_cmd.png" class="">

<p>重點來了!! 可以使用 <code>:cn</code> (<code>:cnext</code>) 跳到下一個錯誤位置，<code>:cp</code> (<code>:cprevious</code>) 跳轉到上一個錯誤位置，就不需要自己手動一個一個錯誤找出來。<br>看上圖，可以觀察到，每一條錯誤前面都有一個數字，如果想要跳到特定錯誤去修那就使用 <code>:cc [number]</code>，跳轉到第一個錯誤就用 <code>:cc 12</code>，跳轉到第三個錯誤就用 <code>:cc 19</code>。</p>
<p>火力展示:</p>
<img data-src="/2020/09/10/vim-make/clist_demo.gif" class="">

<p>總結一下指令:</p>
<ul>
<li><code>:make</code>: 執行 makefile</li>
<li><code>:cl</code>: 列出所有錯誤</li>
<li><code>:cn</code>: 跳到下個錯誤</li>
<li><code>:cp</code>: 跳到上個錯誤</li>
<li><code>:cc [number]</code>: 跳轉到特定錯誤</li>
</ul>
<h2 id="如虎添翼的-quickfix-window"><a href="#如虎添翼的-quickfix-window" class="headerlink" title="如虎添翼的 quickfix-window"></a>如虎添翼的 quickfix-window</h2><p>編譯完之後，除了用 <code>:cl</code> 查看，另一種方式就是用 <code>:copen</code>，打下此指令之後，將會彈出 quickfix-window，列出的錯誤其實就是 <code>:clist</code> 的詳細版本， quickfix-window 只是提供了一種查找的方式。</p>
<img data-src="/2020/09/10/vim-make/copen_cmd.png" class="">
<p>移轉到 quickfix-window 後，移動到想要查看的錯誤，案 <code>enter</code> 即可跳轉到該錯誤位置，當然也能配合 <code>:cn</code>, <code>:cp</code>, <code>:cc [number]</code>，quickfix-window 會配合這些指令連動顯示目前位置。</p>
<p>Note: 詳見 <code>:help quickfix-window</code></p>
<h1 id="讓你飛起來的-vim-dispatch"><a href="#讓你飛起來的-vim-dispatch" class="headerlink" title="讓你飛起來的 vim-dispatch"></a>讓你飛起來的 vim-dispatch</h1><p>使用 vim 內建的 <code>:make</code> 指令，在編譯時其實是會 block 整個 vim 的，若專案夠大編譯很久，那段時間什麼都不能做，只能看著他編譯，vim-dispatch 完美解決了這個問題。</p>
<p>安裝:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'tpope/vim-dispatch'</span></span><br></pre></td></tr></table></figure>

<p>其實 vim-dispatch 用法很簡單，<code>:Make</code> 編譯，<code>:Copen</code> 打開 quickfix-window，當然也能配合剛剛所提到的跳轉指令使用，幾乎完美配合 vim 的使用習慣。</p>
<p>當然 vim-dispatch 不只這樣而已，其他功能不在本篇範圍，詳情請見 vim-dispatch 的文件。</p>
<p>火力展示，可以看到上方的視窗可以移動 cursor，下方則繼續編譯:</p>
<img data-src="/2020/09/10/vim-make/Make_demo.gif" class="">

<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h1><h2 id="vim-使用-make-指令，那不是只有寫-Makefile-才能用嗎"><a href="#vim-使用-make-指令，那不是只有寫-Makefile-才能用嗎" class="headerlink" title="vim 使用 :make 指令，那不是只有寫 Makefile 才能用嗎?"></a>vim 使用 <code>:make</code> 指令，那不是只有寫 Makefile 才能用嗎?</h2><p>當然在想在其他語言使用 <code>:make</code> 指令，達到一樣效果就要編寫客製化的 plugin 了，當然很受歡迎的語言都有人寫好啦，通常都是包在語言 plugin 裡：</p>
<ul>
<li><a href="https://github.com/rust-lang/rust.vim" target="_blank" rel="noopener">rust.vim</a>: 原本編譯方式是 <code>cargo build</code>，在 vim 裡變成 <code>:make build</code> 就好，以此類推可以 <code>:make run</code></li>
<li><a href="https://github.com/fatih/vim-go" target="_blank" rel="noopener">vim-go</a>:在 vim-go 可以使用 <code>:GoBuild</code>, <code>:GoRun</code></li>
</ul>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>vim 是一個古老的編輯器，某些特色和 C 語言沾上關係，比如說 make 指令 (或許當年 C 語言獨佔天下!?)，當然 vim 不只可以使用 make 這種自動化編譯，vim 也開放了幾個 api 使得再起他語言也能達成一樣的效果 (詳見 <code>:help makeprg</code>)，在專案愈大時愈能顯現其效果，當年我也是碰了一點 linux kernel，才學習到這個技巧，加速了不少開發速度。</p>
<p>如果有什麼相關技巧，歡迎在底下留言交流。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.ptt.cc/bbs/Editor/M.1285722960.A.BF5.html" target="_blank" rel="noopener">Re: [轉錄][問題] VIM 編譯與執行</a></li>
<li>vim help doc</li>
</ul>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊 vim mark 使用情境 - code 參照</title>
    <url>/2020/09/07/vim-mark-tips/</url>
    <content><![CDATA[<img data-src="/2020/09/07/vim-mark-tips/cover.png" class="">
<p>寫程式的時候常常遇到一種情況，假設你是團隊的新人，需要常常參照別人的程式，看看團隊的 coding style 等等，可能需要參照 A file 的第 10 行，B file 第 8 行，C file 第 999 行。</p>
<p>另一種情境則是在寫測試的時候會和實作交互參照，而測試程式往往和實作程式會拆開不同的檔案，所以就必須要一直跳轉。</p>
<p>使用 split 的方式縱然是一個不錯的方式，但是如果要參照的點大於三個，就將螢幕切成三份，那工程師就相當痛苦了，不是每個人都用這種電腦螢幕啊。這種 split 的方式還有另一個缺點：如果手殘將檔案關掉，就得重找。</p>
<img data-src="/2020/09/07/vim-mark-tips/cj890.jpg" class="">

 <a id="more"></a>

<h1 id="Mark"><a href="#Mark" class="headerlink" title="Mark"></a>Mark</h1><p>vim 的 mark 取名或許源自於 bookmark (書籤) 這個字，書籤的用意在於能快速找回你上次看的那一頁，而 vim mark 的用意也是如此：能快速找回你剛剛在看 code 的地方。</p>
<p>vim 的 mark 分為三種：</p>
<ul>
<li>Local mark <code>a-z</code>： 每一個 file 裡皆有自己的 local mark，也就是說檔案 A 可以有 mark a, 檔案 B 裡也可以有自己的 mark a</li>
<li>Global mark <code>A-Z</code>： 此種 mark 是全域的，也就是說在檔案 A 裡所看到的 mark A 和 B 檔案 B 裡的 mark A 是一樣的</li>
<li>Special mark：其他神奇的 mark，不在此文章討論範圍</li>
</ul>
<p>mark 的基本使用：</p>
<ul>
<li><code>ma</code>： 在這個地方設置 mark a</li>
<li><code>mA</code>： 在這個地方設置 mark A</li>
<li><code>&#39;a</code>： 跳到 mark a 的這行 (此行的第一個非空白字元)</li>
<li><code>`a</code>： 精準的跳到你當初設置 mark a 的位置 (第幾行第幾列)</li>
<li><code>:marks</code>： 列出來所有 mark，有時候 mark 設置太多會忘</li>
</ul>
<p>更多詳細操作請參照 Reference 3</p>
<h1 id="回到正題"><a href="#回到正題" class="headerlink" title="回到正題"></a>回到正題</h1><p>還記得一開始的情境敘述嗎？<br>雖然你已經知道要在 A file 第 10 行 <code>mA</code>， 在 B file 第 8 行 <code>mB</code>，C file 第 999 行 <code>mC</code>。</p>
<p>實際上在寫 code 時我會這樣做：</p>
<ul>
<li>我會先將我需要參照的地方找出並且 mark，以剛剛的例子來說就是在 A file 第 10 行 <code>mA</code> 在 B file 第 8 行 <code>mB</code>，C file 第 999 行 <code>mC</code></li>
<li>使用 <code>:vsplit</code> 將螢幕切成兩邊，左邊寫 code，右邊當參照區域</li>
<li>需要參照 B 這個位置時，移動到參照區域 ，<code>&#39;B</code> 再移動回寫 code 區域繼續寫</li>
</ul>
<img data-src="/2020/09/07/vim-mark-tips/mark_show.png" class="">

<p>那 local mark 什麼時候用？<br>當一個檔案大於 1000 行，寫的程式在 1001 行，但你需要參照的程式在第一行，也就是都在同一個 file 跳轉的時候可以使用。</p>
<h1 id="search-小技巧"><a href="#search-小技巧" class="headerlink" title="search 小技巧"></a>search 小技巧</h1><p>每次在使用 <code>/</code> 搜尋一定會案 <code>n</code> 或 <code>N</code> 到處跳轉，尋找目標，常常找完了之後，忘記我原本的地方在哪了，此時就能先用 mark 記住後在開始用 <code>/</code> 查找。<br>由於常使用這種操作，所以直接這樣：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> / ms/</span><br></pre></td></tr></table></figure>
<p> 在<code>/</code>搜尋完後，要跳回原本的地方就 <code>&#39;s</code> 就好</p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>人類總是會在大量的資料中迷失，並且花上很多時間查找和記憶，標記(或是書籤)就是其中一種解決方案，而且應用不只在書上，到處都可以看到類似的應用，像是檔案夾的標籤、英文書在最後會有的索引，然而在寫程式上也不例外。不管是在寫 code 上還是其他應用，好好的應用這些工具將能事半功倍。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://medium.com/usevim/vim-101-marks-caad7106b241" target="_blank" rel="noopener">https://medium.com/usevim/vim-101-marks-caad7106b241</a></li>
<li><a href="https://medium.com/usevim/vim-101-practicing-marks-fc5778d8aaea" target="_blank" rel="noopener">https://medium.com/usevim/vim-101-practicing-marks-fc5778d8aaea</a></li>
<li><a href="https://vim.fandom.com/wiki/Using_marks" target="_blank" rel="noopener">https://vim.fandom.com/wiki/Using_marks</a></li>
</ol>
]]></content>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
      </tags>
  </entry>
  <entry>
    <title>你應該擴充的 text object</title>
    <url>/2020/09/22/vim-text-object/</url>
    <content><![CDATA[<p>vim 高效率編輯的背後，operator, motion, text object 的配合功不可沒。</p>
<p>operator 是編輯的動作， text object 就是文字區塊，motion 是跳轉到文件點，透過三者的按鍵配合，就能達到所想及所得的編輯方式。</p>
<p>如果你有看過別人使用 vim ，通常會有這種想法：怎麼隨便按幾個鍵就刪這裡刪那裡複製這裡複製那裡，速度快到看不懂在幹嘛，而且還不會出錯，因為只要想好要做什麼，按鍵按下去就對了，這也是為什麼會高效率。說了一堆，反正就是 <del><strong>耍潮必備</strong></del>。</p>
<p>本篇將會提到:</p>
<ul>
<li><p>operator, text object, motion 的配合用法</p>
</li>
<li><p>內建 text object 的不足之處</p>
</li>
<li><p>擴充 text object 的 plugin</p>
</li>
<li><p>淺談 nvim-treesitter </p>
<a id="more"></a>

</li>
</ul>
<h1 id="Operator-amp-text-object"><a href="#Operator-amp-text-object" class="headerlink" title="Operator &amp; text object"></a>Operator &amp; text object</h1><p>Vim 定義了多個 operator 最常用的就是:</p>
<ul>
<li><code>d</code> delete (刪除)</li>
<li><code>c</code> change (更改)</li>
<li><code>y</code> yank (複製)</li>
</ul>
<p><strong>operator</strong> 沒有配合 text object 或是 motion 是沒有意義的，想像一下使用了 <code>d</code> 刪除，但是沒告訴它要刪除什麼，就像有了鐵鎚不知道要打什麼。所以需要給 operator 一個目標，讓它要對誰做什麼。這個誰就有兩種，motion 和 text object。</p>
<p><strong>motion</strong>：其實就是跳轉指令，像是常用的 <code>G</code>,<code>gg</code>, <code>w</code>, <code>f{char}</code> … 等都可以配合 operator。基本使用方法為 <code>{operator}{motion}</code>，語意就是做這個 operator 動作到 motion 所到的地方</p>
<p>以 <code>d</code> operator 做舉例的話 (其他 operator 以此類推):</p>
<ul>
<li><code>dG</code>: 刪除 從游標到檔案的尾部</li>
<li><code>dgg</code>: 刪除 從游標到檔案的頭部</li>
<li><code>dw</code>: 刪除 從游標到下一個字</li>
<li><code>dfz</code>: 刪除 從游標底下到達此行 z 這個字母 (如果此行無 z 則不動作)</li>
</ul>
<p><strong>text object</strong>： 通常是已經定義的一個範圍，像是 word, quote, () block … 等。內建的 text object 都會有 i 或 a 為前輟，i 表示 inside (不包含的概念)、 a 表示 around (包含的概念)。</p>
<p>常用的 text object:</p>
<ul>
<li><code>iw</code> ：游標下的字不包含後面的空白 (英文斷字使用空白)</li>
<li><code>aw</code> ：游標下的字包含後面的空白 (英文斷字使用空白)</li>
<li><code>i&quot;</code> ：游標下在雙引號裡的所有字不包含雙引號 </li>
<li><code>a&quot;</code> ：游標下在雙引號裡的所有字包含雙引號</li>
<li><code>i(</code>, <code>i)</code> ：游標下在小括號裡的所有字不包含小括號</li>
<li><code>a(</code>, <code>a)</code> ：游標下在小括號裡的所有字包含小括號</li>
</ul>
<p>基本使用方式為 <code>{operator}{text object}</code>，語意就是對此 text object 做這個operator 動作<br>使用 <code>d</code> operator 做舉例:</p>
<ul>
<li><code>diw</code> ：刪除 游標下的字不包含後面的空白 (英文斷字使用空白)</li>
<li><code>daw</code> ：刪除 游標下的字包含後面的空白 (英文斷字使用空白)</li>
<li><code>di&quot;</code> ：刪除 游標下在雙引號裡的所有字不包含雙引號 </li>
<li><code>da&quot;</code> ：刪除 游標下在雙引號裡的所有字不包含雙引號</li>
<li><code>di(</code>, <code>di)</code> ：刪除 游標下在小括號裡的所有字不包含雙引號</li>
<li><code>da(</code>, <code>da)</code> ：刪除 游標下在小括號裡的所有字包含雙引號</li>
</ul>
<blockquote>
<p>建議自己把 <code>:help motion.txt</code> 翻一翻，找出自己常用的 text object 看一看，寫成一個 cheat sheet</p>
</blockquote>
<p>雖然 vim 定義了大量的 text object，但可能大部分都不是你想要的，那就透過 plugin 來滿足需求吧。</p>
<h1 id="簡單好用的-vim-textobj-user"><a href="#簡單好用的-vim-textobj-user" class="headerlink" title="簡單好用的 vim-textobj-user"></a>簡單好用的 vim-textobj-user</h1><p>kana 所發展的 <a href="https://github.com/kana/vim-textobj-user" target="_blank" rel="noopener">kana/vim-textobj-user</a> 是一個 lib，讓使用者藉由這個 lib 輕鬆的製作屬於自己的  text object，所以就有一些 plugin 基於此 lib 做出更多的 text object，這些 plugin 的名字通常都叫 vim-textobj-xxx 。</p>
<p>使用 plugin 的方法為：</p>
<ul>
<li>安裝 <a href="https://github.com/kana/vim-textobj-user" target="_blank" rel="noopener">kana/vim-textobj-user</a></li>
<li>在 <a href="https://github.com/kana/vim-textobj-user/wiki" target="_blank" rel="noopener">wiki</a> 裡查看自己所需的 text object plugin，並且安裝</li>
</ul>
<p>舉例來說：我最常用的兩個 text object 是 comment 和 funtion parameter，所以我選定  <a href="https://github.com/glts/vim-textobj-comment" target="_blank" rel="noopener">glts/vim-textobj-comment</a> 和 <a href="https://github.com/sgur/vim-textobj-parameter" target="_blank" rel="noopener">sgur/vim-textobj-parameter</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'kana/vim-textobj-user'</span></span><br><span class="line">Plug <span class="string">'glts/vim-textobj-comment'</span></span><br><span class="line">Plug <span class="string">'sgur/vim-textobj-parameter'</span></span><br></pre></td></tr></table></figure>
<p>vim-textobj-comment 提供了：</p>
<ul>
<li><code>ic</code>：comment 內容</li>
<li><code>ac</code>：comment 內容 + comment 符號</li>
</ul>
<p>vim-textobj-parameter 提供了：</p>
<ul>
<li><code>i,</code>：參數</li>
<li><code>a,</code>：參數符號 + 分隔符號 (也就是逗號)</li>
</ul>
<h1 id="更細膩的-text-object-targets-vim"><a href="#更細膩的-text-object-targets-vim" class="headerlink" title="更細膩的 text object - targets.vim"></a>更細膩的 text object - targets.vim</h1><p><a href="https://github.com/wellle/targets.vim" target="_blank" rel="noopener">wellle/targets.vim</a> 把 text object 的種類拆成四類型：</p>
<ul>
<li>Pair text objects - <code>(</code> <code>)</code> <code>{</code> <code>}</code> <code>[</code> <code>]</code> <code>&lt;</code> <code>&gt;</code> </li>
<li>Quote text objects -  <code>&#39;</code> <code>&quot;</code> <code>`</code></li>
<li>Separator text objects - <code>, . ; : + - = ~ _ * # / | \ &amp; $</code></li>
<li>Argument text objects</li>
<li>Tag text objects</li>
</ul>
<p>Pair 和 Quote text objects 是 vim 原本就有的概念，Separator text objects 如其名，兩個 separator 之間的字就是 Separator text objects 了。<br>舉個使用情境：url GET 參數都用 <code>&amp;</code> 所隔開，如果想刪除 <code>&amp;</code> 之間的字那就用得上了</p>
<p>內建的 text object 使用了 i 和 a 做前輟，而 targets.vim 更為細膩，提供了額外的 I 和 A 擴充原本的 i 和 a，再加上一層概念 <code>n</code> 和 <code>l</code>，<code>n</code> 代表下一個，<code>l</code> 則代表上一個。</p>
<p>註：內建的 text object 都是以游標位置為準，沒上一個和下一個的概念</p>
<p>以 <code>)</code> 做個舉例：</p>
<ul>
<li><code>i)</code>：包含括號裡的所有字</li>
<li><code>I)</code>：包含括號裡的所有字，但括號裡兩邊的空白不包含</li>
<li><code>a)</code>：包含括號和括號裡的所有字</li>
<li><code>A)</code>：包含括號和括號裡的所有字還有兩邊括號外的空白</li>
</ul>
<p>加上 <code>n</code> 和 <code>l</code> 的話就是下一個跟上一個</p>
<p><code>.</code> 表示游標所在位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                           ..........</span><br><span class="line">a ( b ( cccccccc ) d ) ( e ( ffffff ) g ) ( h ( iiiiiiii ) j ) k</span><br><span class="line">  │││ ││└ 2Il) ┘││││││││││ ││└ I) ┘││││││││││ ││└ 2In) ┘│││││││</span><br><span class="line">  │││ │└─ 2il) ─┘│││││││││ │└─ i) ─┘│││││││││ │└─ 2in) ─┘││││││</span><br><span class="line">  │││ ├── 2al) ──┘││││││││ ├── a) ──┘││││││││ ├── 2an) ──┘│││││</span><br><span class="line">  │││ └── 2Al) ───┘│││││││ └── A) ───┘│││││││ └── 2An) ───┘││││</span><br><span class="line">  ││└───── Il) ────┘│││││└─── 2I) ────┘│││││└───── In) ────┘│││</span><br><span class="line">  │└────── il) ─────┘│││└──── 2i) ─────┘│││└────── in) ─────┘││</span><br><span class="line">  ├─────── al) ──────┘│├───── 2a) ──────┘│├─────── an) ──────┘│</span><br><span class="line">  └─────── Al) ───────┘└───── 2A) ───────┘└─────── An) ───────┘</span><br></pre></td></tr></table></figure>
<p>target.vim 提供的 text object 實在太多太複雜，所以很貼心的做了 <a href="https://github.com/wellle/targets.vim/blob/master/cheatsheet.md" target="_blank" rel="noopener">cheat sheet</a></p>
<h1 id="syntax-相關-text-object"><a href="#syntax-相關-text-object" class="headerlink" title="syntax 相關 text object"></a>syntax 相關 text object</h1><p>以上所提到的 text object 都是和程式語言較無相關的 text object。程式語言相關的 text object，比如說 function, class, structure⋯⋯，這些相關的 text object plugin 相對來說比較少見。</p>
<p>vim 並沒有提供一個介面直接拿取 syntax tree 的某一個 node，所以現在的所有 text object 的 plugin 都是靠 regex 或是其他字串比對的方式。假如想要一個 function 的 text object，就必須在每種語言都用 regex 或字串比對做一遍，相當的麻煩，<a href="https://github.com/kana/vim-textobj-function" target="_blank" rel="noopener">kana/vim-textobj-function</a> 就是一個例子，目前只提供三種語言，並且每種語言實做一次。</p>
<p>一個 text object 為主的 plugin 想要集成所有的 syntax 相關 text object 變得不太可能，所以這些 syntax 相關 text object plugin 通常都已一種語言為主，或是附屬在某些語言 plugin 底下：</p>
<ul>
<li>vim-go 提供了 comment (<code>ac</code>, <code>ic</code>) 和 function (<code>af</code>, <code>if</code>) text object</li>
<li><a href="https://github.com/sgur/vim-textobj-parameter" target="_blank" rel="noopener">sgur/vim-textobj-parameter</a> 為 python syntax 相關的 text object</li>
<li><a href="https://github.com/mjbrownie/django-template-textobjects" target="_blank" rel="noopener">mjbrownie/django-template-textobjects</a> 為 django-template 相關的 text object</li>
</ul>
<h1 id="救世主-treesitter"><a href="#救世主-treesitter" class="headerlink" title="救世主 treesitter"></a>救世主 treesitter</h1><p>一個 text object 為主的 plugin 想要集成所有的 syntax 相關 text object 真的不可能達到嗎？<br>等到 Treesitter 被 neovim 整合完成後一切將變得簡單許多。</p>
<p>Treesitter 簡單來講就是個 parser，可以使用它建立 syntax tree，官方介紹如下：<br>Tree-sitter is a parser generator tool and an incremental parsing library. It can build a concrete syntax tree for a source file and efficiently update the syntax tree as the source file is edited</p>
<p>neovim 0.5 版的目標就是要將 treesitter 整合，完成之後將可在 neovim 裡使用 treesitter 相關的 api，拿到了 syntax tree， 要抓到 text object 變得容易許多。別說做 text object plugin 了，連 syntax highlight, code folding 等相關 plugin 都可以不需倚賴 regex ，而目前已經有基於 treesitter 的 plugin 了：<br><strong><a href="https://github.com/nvim-treesitter/nvim-treesitter" target="_blank" rel="noopener">nvim-treesitter/nvim-treesitter</a></strong></p>
<p>詳見 <code>:help treesitter-parsers</code></p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p><a href="https://github.com/wellle/targets.vim" target="_blank" rel="noopener">wellle/targets.vim</a> 和 <a href="https://github.com/kana/vim-textobj-user" target="_blank" rel="noopener">kana/vim-textobj-user</a> 在開發上使用截然不同的方式，前者定義好大量細膩的 text object，後者則是一個 lib，由使用者以此 lib 為基礎在開發 plugin。</p>
<p>對我來說，內建的 text object 已經足夠強大幾乎滿足需求，只需要在做一點補強，像是常用的 comment 和 funtion parameter 就沒有被 vim 定義。而 target.vim 大量細膩的 text object 使用情境都比較特殊，所以我就選擇了 vim-textobj-user 陣營——只選擇自己所需要的安裝，不會有多餘的功能。</p>
<p><a href="https://github.com/nvim-treesitter/nvim-treesitter" target="_blank" rel="noopener">nvim-treesitter/nvim-treesitter</a> 倚賴 syntax tree 解決了使用 regex 開發 text object plugin 的麻煩，而且更精準，可以預見 neovim 0.5 完成後的未來，syntax 相關的 text object plugin 將會被此 plugin 統一。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://codeinthehole.com/tips/vim-text-objects/" target="_blank" rel="noopener">https://codeinthehole.com/tips/vim-text-objects/</a></li>
<li><a href="https://www.tandrewnichols.me/motions-operators-text-objects-introduction/" target="_blank" rel="noopener">https://www.tandrewnichols.me/motions-operators-text-objects-introduction/</a></li>
<li><a href="https://neovim.io/doc/user/motion.html" target="_blank" rel="noopener"><code>:help &#39;motion.txt&#39;</code></a></li>
</ul>
]]></content>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 78 語法篇 - method set</title>
    <url>/2020/07/07/golang78syntax2/</url>
    <content><![CDATA[<p><code>method set</code>, <code>interface</code>, <code>auto deference or reference</code> 當這些語法綜合再一起使用時，很容易混淆，甚至寫出 bug code，這章我們就透過題目探討一下 <code>method set</code> 常常被大家誤會的地方。</p>
<a href="/2020/07/03/golang78syntax/" title="Golang 78 語法篇 - interface">Golang 78 語法篇 - interface</a> Line 50 用到的概念就在這篇。


<h1 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h1><p>請問以下程式輸出結果為何</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">DoWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"do work"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	(&amp;Employee&#123;&#125;).DoWork()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案只有兩種方向:<br>    1. 無法編譯<br>    2. 印出 do work</p>
<p>這個程式可以編譯，並且還印出 do work 但是為什麼呢？</p>
 <a id="more"></a>

<h1 id="Method-set"><a href="#Method-set" class="headerlink" title="Method set"></a>Method set</h1><p>在 receiver argument 和 receiver parameter 不一樣的情況下，直覺反應就是 <code>implicit dereference</code> 和 <code>implicit reference</code> 在背後會幫忙，但是這個寫法 (struct literal) 是不會有此情況的。</p>
<p>既然沒有 <code>implicit dereference</code> 和 <code>implicit reference</code> 的支援，那一定存在其它機制使得這段 code 能正常編譯。</p>
<p>以下從 <a href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener">Golang Specification</a>所截取的句子:</p>
<p>The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T)</p>
<p>以下是從 <a href="https://golang.org/doc/faq#different_method_sets" target="_blank" rel="noopener">Golang FAQ</a> 所截取的句子:</p>
<p>As the Go specification says, the method set of a type T consists of all methods with receiver type T, while that of the corresponding pointer type *T consists of all methods with receiver *T or T. That means the method set of *T includes that of T, but not the reverse</p>
<p>其實意思就是型態 T 的所有 method 包含了所有 receiver 型態是 T 的 method，這理所當然，看起來也像廢話，另一句才是關鍵，也是今日的重點：*T 型態的所有 method 包含了 receiver 型態是 T 及 *T 的 method。</p>
<p>有了此結論我們就能知道 <code>*Employee</code> 的 method set 裡是有 <code>DoWork()</code>，所以編譯會過。</p>
<p>那這就有趣了，再看一個延伸題，請問這段 code 編譯會不會過:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Worker <span class="keyword">interface</span> &#123;</span><br><span class="line">	DoWork()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">DoWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"do work"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> w Worker = &amp;Employee&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這段 code 問的其實就是 Employee 到底有沒有符合(satisfy) <code>Worker</code> 介面，根據剛剛所得出的結論， <code>*Employee</code> 的 method set 裡是有包含 <code>DoWork</code> 的，所以編譯是會過的。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://golang.org/doc/faq#different_method_sets" target="_blank" rel="noopener">Golang Frequently Asked Questions (FAQ)</a></li>
<li><a href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener">The Go Programming Language Specification - Method sets</a></li>
</ol>
]]></content>
      <categories>
        <category>golang78 syntax series</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>vim 高亮 yank 區域</title>
    <url>/2020/09/29/vim-tips-highlight-yank-region/</url>
    <content><![CDATA[<p><code>y</code> 是在 vim 裡最常使用的使用的 operator 之一，使用 <code>y</code> operator 將會執行 yank 動作，但它無法像 <code>c</code> (change) 和 <code>d</code> (delete) operator 使用之後馬上就知道對文件編輯了什麼。yank 動作是沒有反饋的，按了 <code>yiw</code> 複製 word 之後，你也無法確定是不是按對了，還要使用 <code>:reg</code> 檢視，頗麻煩的。</p>
<p>解決方案：在使用 yank operator 之後，高亮複製區域短暫的時間，就能確認複製的區域有沒有誤。以下圖例為，在 23 行按下 <code>yy</code>, 在 24 行的 return 上按下 <code>yiw</code></p>
<img data-src="/2020/09/29/vim-tips-highlight-yank-region/cover.gif" class="">
 <a id="more"></a>

<p>在 neovim 0.5 裡達到這件事相當簡單，把以下加近</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> TextYankPost * silent! <span class="keyword">lua</span> <span class="keyword">vim</span>.<span class="keyword">highlight</span>.on_yank&#123;higroup=<span class="string">"IncSearch"</span>, timeout=<span class="number">300</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果是使用 vim 也可以用 <a href="https://github.com/machakann/vim-highlightedyank" target="_blank" rel="noopener">vim-highlightedyank</a> 套件達成</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'machakann/vim-highlightedyank'</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:highlightedyank_highlight_duration</span> = <span class="number">300</span></span><br><span class="line"><span class="keyword">if</span> !exists(<span class="string">'##TextYankPost'</span>)</span><br><span class="line">  <span class="keyword">map</span> <span class="keyword">y</span> <span class="symbol">&lt;Plug&gt;</span>(highlightedyank)</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://github.com/neovim/neovim/pull/12279" target="_blank" rel="noopener">https://github.com/neovim/neovim/pull/12279</a></li>
<li>neovim <code>:help lua-highlight</code></li>
</ul>
]]></content>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
      </tags>
  </entry>
</search>

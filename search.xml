<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang 78 語法篇 - method set</title>
    <url>/2020/07/07/golang78syntax2/</url>
    <content><![CDATA[<p><code>method set</code>, <code>interface</code>, <code>auto deference or reference</code> 當這些語法綜合再一起使用時，很容易混淆，甚至寫出 bug code，這章我們就透過題目探討一下 <code>method set</code> 常常被大家誤會的地方。</p>
<p><a href="golang78syntax.md">Golang 78 語法篇 - interface</a>  <code>Line 50</code> 的概念就在這篇。</p>
<h1 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h1><p>請問以下程式輸出結果為何</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">DoWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"do work"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	(&amp;Employee&#123;&#125;).DoWork()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案只有兩種方向:<br>    1. 無法編譯<br>    2. 印出 do work</p>
<p>這個程式可以編譯，並且還印出 do work 但是為什麼呢？</p>
<h1 id="Method-set"><a href="#Method-set" class="headerlink" title="Method set"></a>Method set</h1><p>在 receiver argument 和 receiver parameter 不一樣的情況下，直覺反應就是 <code>implicit dereference</code> 和 <code>implicit reference</code> 在背後會幫忙，但是這個寫法 (struct literal) 是不會有此情況的。</p>
<p>既然沒有 <code>implicit dereference</code> 和 <code>implicit reference</code> 的支援，那一定存在其它機制使得這段 code 能正常編譯。</p>
<p>以下從 <a href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener">Golang Specification</a>所截取的句子:</p>
<p>The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T)</p>
<p>以下是從 <a href="https://golang.org/doc/faq#different_method_sets" target="_blank" rel="noopener">Golang FAQ</a> 所截取的句子:</p>
<p>As the Go specification says, the method set of a type T consists of all methods with receiver type T, while that of the corresponding pointer type *T consists of all methods with receiver *T or T. That means the method set of *T includes that of T, but not the reverse</p>
<p>其實意思就是型態 T 的所有 method 包含了所有 receiver 型態是 T 的 method，這理所當然，看起來也像廢話，另一句才是關鍵，也是今日的重點：*T 型態的所有 method 包含了 receiver 型態是 T 及 *T 的 method。</p>
<p>有了此結論我們就能知道 <code>*Employee</code> 的 method set 裡是有 <code>DoWork()</code>，所以編譯會過。</p>
<p>那這就有趣了，再看一個延伸題，請問這段 code 編譯會不會過:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Worker <span class="keyword">interface</span> &#123;</span><br><span class="line">	DoWork()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">DoWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"do work"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> w Worker = &amp;Employee&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這段 code 問的其實就是 Employee 到底有沒有符合(satisfy) <code>Worker</code> 介面，根據剛剛所得出的結論， <code>*Employee</code> 的 method set 裡是有包含 <code>DoWork</code> 的，所以編譯是會過的。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://golang.org/doc/faq#different_method_sets" target="_blank" rel="noopener">Golang Frequently Asked Questions (FAQ)</a></li>
<li><a href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener">The Go Programming Language Specification - Method sets</a></li>
</ol>
]]></content>
      <categories>
        <category>golang78 syntax series</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>fib_practice</title>
    <url>/2020/07/11/fib-practice/</url>
    <content><![CDATA[<p>$$\begin{align}<br>a &amp;= b + c \label{eq3} \<br>x &amp;= yz \label{eq4}\<br>l &amp;= m - n \label{eq5}<br>\end{align}$$</p>
]]></content>
  </entry>
  <entry>
    <title>Golang 78 語法篇 - interface</title>
    <url>/2020/07/03/golang78syntax/</url>
    <content><![CDATA[<p>Interface 可以說是 golang 的精髓之一。golang interface 特殊的語法以及概念也是工程師常常犯錯的地方。此題只是用來釐清自己的概念。</p>
<h1 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h1><p>請問以下程式輸出結果為何</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;</span><br><span class="line">    val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">F</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IF <span class="keyword">interface</span> &#123;</span><br><span class="line">	F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitType</span><span class="params">()</span> <span class="title">S</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitPointer</span><span class="params">()</span> *<span class="title">S</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitEfaceType</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitEfacePointer</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">var</span> s *S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitIfaceType</span><span class="params">()</span> <span class="title">IF</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitIfacePointer</span><span class="params">()</span> <span class="title">IF</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// fmt.Println(InitType() == nil) // type mismatch</span></span><br><span class="line">	fmt.Println(InitPointer() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitEfaceType() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitEfacePointer() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitIfaceType() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitIfacePointer() == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="回歸基本"><a href="#回歸基本" class="headerlink" title="回歸基本"></a>回歸基本</h1><p>在回答問題之前先複習什麼是 <code>Interface Satisfaction</code> 和 <code>Interface Values</code> ，分別在 The Go Programming Language 章節 7.3 和 7.5。</p>
<h2 id="Interface-Satisfaction"><a href="#Interface-Satisfaction" class="headerlink" title="Interface Satisfaction"></a>Interface Satisfaction</h2><p>直接給出書上的解釋，這兩段句子及範例程式已經淺顯易懂，不多作解釋:</p>
<p>A type <code>satisfies</code> an interface if it possesses all the methods the interface requires.</p>
<p>The assignability rule for interfaces is very simple: an expression may be assigned to an interface only if its type satisfies the interface.</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package io</span></span><br><span class="line"><span class="comment">type Writer interface &#123;</span></span><br><span class="line"><span class="comment">    Write(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout           <span class="comment">// OK: *os.File has Write method</span></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)   <span class="comment">// OK: *bytes.Buffer has Write method</span></span><br><span class="line">w = time.Second         <span class="comment">// compile error: time.Duration lacks Write method</span></span><br></pre></td></tr></table></figure>

<h2 id="Interface-Values"><a href="#Interface-Values" class="headerlink" title="Interface Values"></a>Interface Values</h2><p>The Go Programming Language 7.5 第一句開門見山地馬上給出概念:</p>
<p>Conceptually, a value of an interface type, or <code>interface value</code> has two components, a concrete type and a value of that type . These are called the interface’s <code>dynamic type</code> and <code>dynamic value</code>.</p>
<p>並且用一個例子做出了很棒的解釋:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<img src="/2020/07/03/golang78syntax/golang78syntax_1.jpg" class="" title="line1 - line4">

<p>另一個例子:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line"><span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">w = buf</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%v %T\n"</span>, w, w) <span class="comment">// &lt;nil&gt;  *bytes.Buffer</span></span><br><span class="line"><span class="keyword">if</span> w != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"w not nil"</span>) <span class="comment">// This line will be executed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若 <code>w != nil</code> 要成立則 <code>dynamic type</code> 和 <code>dynamic value</code> 皆為 <code>non-nil</code> 才會成立。<br>因為 w 的 dynamic value 是 <code>*bytes.Buffer</code> 不為 <code>nil</code> 所以 <code>w != nil</code> 就會成立。</p>
<img src="/2020/07/03/golang78syntax/golang78syntax_2.jpg" class="">

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>題目的 Line 43, 44 難度不高，直接跳過<br>剩下的看下圖</p>
<img src="/2020/07/03/golang78syntax/golang78syntax_3.jpg" class="">

<p>Line 50 牽扯到了 <code>method set</code> 的細節，留著下篇解釋，可以參考 Reference 1, 2</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener">https://golang.org/ref/spec#Method_sets</a></li>
<li><a href="https://stackoverflow.com/questions/33587227/method-sets-pointer-vs-value-receiver" target="_blank" rel="noopener">https://stackoverflow.com/questions/33587227/method-sets-pointer-vs-value-receiver</a></li>
</ol>
]]></content>
      <categories>
        <category>golang78 syntax series</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
</search>

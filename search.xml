<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang 開發環境 - 使用 neovim</title>
    <url>/2020/09/03/go_neovim_env/</url>
    <content><![CDATA[<img data-src="/2020/09/03/go_neovim_env/cover.png" class="">

<h1 id="你確定要用-neovim-開發-golang"><a href="#你確定要用-neovim-開發-golang" class="headerlink" title="你確定要用 neovim 開發 golang?"></a>你確定要用 neovim 開發 golang?</h1><p>現在是 vscode 稱霸天下的時代，理所當然的 (neo)vim 也常常被拿來 vscode 比較，vscode 內建整合了 git、debugger、自動補全引擎、terminal、extension manager，另外 Golang 在 vscode 上的 extension 支援相當良好: 包括跳轉到定義 (go to definition)、重新命名 (rename)、跳轉到型態定義 (go to type definition)⋯⋯ 一堆細節功能，近期由於 google golang team 接手 go 語言的 vscode extension，相信使用 vscode 開發是不錯的選擇。</p>
<p> (neo)vim 當然也能達到 vscode 的類似功能，但是必須花時間設定調教，在 vscode 問世之前我會推薦 (Neo)vim 給我的朋友，vscode 問世之後我就開始推薦 vscode。</p>
<blockquote>
<p>本文給那些本來就在 (neo)vim 裡打滾的人，但對 go 語言設定不熟的人，<br>如果你是一張白紙，而且沒有被虐的癖好，我建議選擇 vscode，可以用較少的時間進入到寫程式的環節，而不是一直在花時間在設定，這篇文你也沒必要看下去。</p>
</blockquote>
<h1 id="預備動作"><a href="#預備動作" class="headerlink" title="預備動作"></a>預備動作</h1><p>Must have</p>
<ul>
<li>你應該先安裝好 neovim nightly 版本，<code>brew install neovim --HEAD</code></li>
<li>你應該要知道怎麼使用 vim-plug，至少要知道 <code>:PlugInstall</code></li>
<li>你應該先把 go 語言環境安裝好</li>
</ul>
<p>Nice to have</p>
<ul>
<li>你知道 <code>:checkhealth</code> 和 <code>:UpdateRemotePlugin</code></li>
<li>你熟悉 <code>:help</code> 的使用方式，這裡有一篇好文：<a href="https://vim.fandom.com/wiki/Learn_to_use_help" target="_blank" rel="noopener">Learn to use help</a></li>
</ul>
<h1 id="開發環境基本功能"><a href="#開發環境基本功能" class="headerlink" title="開發環境基本功能"></a>開發環境基本功能</h1><p>一個好用的 Editor 我認為應該包含以下幾點基本功能:</p>
<ul>
<li>Auto completion - 好的自動補全引擎</li>
<li>File manager - 可以在側邊欄看到專案的結構</li>
<li>Real time linter - 在寫 code 犯錯的同時，有一些提示 (也就是 diagnostic 功能)</li>
<li>Background compile - 編譯的同時不應該卡住整個 Editor，要讓使用者能做其他事情</li>
<li>Code navigation: 包含跳轉到定義，跳轉到型態定義，或是當一個檔案寫得很長的時候，怎麼綜觀全局</li>
</ul>
<p>以下我將會介紹我使用的 Plugin，達到我上述所提到的功能。<br>以下使用的皆是 Neovim nightly 版本，使用 stable 是沒有官方 LSP 支援的。</p>
<p>Note：neovim 是由 vim 所 fork 出來的，差異介紹請看<a href="https://kerol2r20.github.io/post/2017-10-29-neovim-introdunction/" target="_blank" rel="noopener">這篇</a>，某些 Plugin 不會同時相容於兩者，我接會標明。</p>
 <a id="more"></a>

<h1 id="File-explorer-defx-nvim"><a href="#File-explorer-defx-nvim" class="headerlink" title="File explorer (defx.nvim)"></a>File explorer (defx.nvim)</h1><img data-src="/2020/09/03/go_neovim_env/defx.png" class="">

<p>為什麼不用老牌的 nerdtree 就好，要使用別的 file explorer，<br>沒辦法 nerdtree 就是慢，只要專案稍微有一點規模，就會有明顯的卡頓。</p>
<p>defx 由 python3 寫成，是一個需要高度手動設定的 file explorer，不像 nerdtree 幾乎可以開箱及用，在設定時一定得查看 defx 的 help 文件，裡頭有相當多設定範例。</p>
<p>為了讓 neovim 知道 python3 在哪，將此行寫入 vimrc：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:python3_host_prog</span> = <span class="string">'/path/to/python3'</span></span><br></pre></td></tr></table></figure>
<p>設定完此行之行 執行 <code>:checkhealth</code>，neovim 就會開始查看有沒有抓到 python3</p>
<p>安裝</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'Shougo/defx.nvim'</span></span><br></pre></td></tr></table></figure>
<p>安裝完後執行 <code>:UpdateRemotePlugins</code></p>
<p>使用 F4 映射到 defx</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;F4&gt;</span> <span class="symbol">&lt;cmd&gt;</span>Defx -<span class="keyword">buffer</span>-name=<span class="string">"defx"</span><span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<p>外觀設定</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> defx#custom#column(<span class="string">'icon'</span>, &#123;</span><br><span class="line">            \ <span class="string">'directory_icon'</span>: <span class="string">'▸'</span>,</span><br><span class="line">            \ <span class="string">'opened_icon'</span>: <span class="string">'▾'</span>,</span><br><span class="line">            \ <span class="string">'root_icon'</span>: <span class="string">'📁 '</span>,</span><br><span class="line">            \ &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> defx#custom#column(<span class="string">'filename'</span>, &#123;</span><br><span class="line">            \ <span class="string">'min_width'</span>: <span class="number">128</span>,</span><br><span class="line">            \ <span class="string">'max_width'</span>: <span class="number">128</span>,</span><br><span class="line">            \ &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> defx#custom#option(<span class="string">'_'</span>, &#123;</span><br><span class="line">            \ <span class="string">'columns'</span>: <span class="string">'mark:indent:icon:filename:type'</span>,</span><br><span class="line">            \ <span class="string">'split'</span>: <span class="string">'vertical'</span>,</span><br><span class="line">            \ <span class="string">'winwidth'</span>: <span class="number">35</span>,</span><br><span class="line">            \ <span class="string">'direction'</span>: <span class="string">'topleft'</span>,</span><br><span class="line">            \ <span class="string">'resume'</span>: <span class="variable">v:false</span>,</span><br><span class="line">            \ <span class="string">'toggle'</span>: <span class="variable">v:true</span></span><br><span class="line">            \ &#125;)</span><br></pre></td></tr></table></figure>

<p>使用 enter 打開或關閉資料夾：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;buffer&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;CR&gt;</span></span><br><span class="line">            \ defx#is_directory() ?</span><br><span class="line">            \ defx#do_action(<span class="string">'open_or_close_tree'</span>) :</span><br><span class="line">            \ defx#do_action(<span class="string">'drop'</span>)</span><br></pre></td></tr></table></figure>


<p>因為 defx 的高度彈性，以及舊有的 nerdtree使用習慣，所以我就把 defx 的 key mapping 設定成類似 nerdtree，這裡就只做基本設定，以後有空會多開一篇詳細講 defx 設定，如果有興趣請參考<a href="https://github.com/amikai/nvimrc/blob/46d4c73f9e/config/defx.vim" target="_blank" rel="noopener">我的設定</a> </p>
<p>Note: defx (neovim only)</p>
<p>類似 Plugin: <a href="https://github.com/preservim/nerdtree" target="_blank" rel="noopener">nerdtree</a> (vim and neovim), <a href="https://github.com/justinmk/vim-dirvish" target="_blank" rel="noopener">vim-dirvish</a> (vim and neovim)</p>
<h1 id="Auto-completion-completion-nvim-amp-diagnostic-diagnostic-nvim"><a href="#Auto-completion-completion-nvim-amp-diagnostic-diagnostic-nvim" class="headerlink" title="Auto completion (completion-nvim) &amp; diagnostic (diagnostic-nvim)"></a>Auto completion (completion-nvim) &amp; diagnostic (diagnostic-nvim)</h1><p>completion-nvim 和 diagnostic-nvim 都是基於 nvim-lspconfig 的 Plugin，<br>可以把 nvim-lspconfig 當成和 language server 溝通的基礎設施，Golang 預設的 language server 當然就是 gopls 啦</p>
<p>安裝</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'neovim/nvim-lspconfig'</span></span><br><span class="line">Plug <span class="string">'nvim-lua/diagnostic-nvim'</span></span><br><span class="line">Plug <span class="string">'nvim-lua/completion-nvim'</span></span><br></pre></td></tr></table></figure>

<p>在 lsp client 時，啟動 <code>completion-nvim</code> 和 <code>diagnostic-nvim</code>：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">lua &lt;&lt; EOF</span><br><span class="line">    <span class="keyword">local</span> nvim_lsp = <span class="built_in">require</span><span class="string">'nvim_lsp'</span></span><br><span class="line">    <span class="keyword">local</span> on_attach_vim = <span class="function"><span class="keyword">function</span><span class="params">(client, bufnr)</span></span></span><br><span class="line">        <span class="built_in">require</span><span class="string">'completion'</span>.on_attach(client, bufnr)</span><br><span class="line">        <span class="built_in">require</span><span class="string">'diagnostic'</span>.on_attach(client, bufnr)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    nvim_lsp.gopls.setup&#123;</span><br><span class="line">        on_attach=on_attach_vim</span><br><span class="line">    &#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><code>diagnostic-nvim</code> 範例設定：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> sign_define(<span class="string">"LspDiagnosticsErrorSign"</span>, &#123;<span class="string">"text"</span> : <span class="string">"E"</span>, <span class="string">"texthl"</span> : <span class="string">"LspDiagnosticsError"</span>&#125;)</span><br><span class="line"><span class="keyword">call</span> sign_define(<span class="string">"LspDiagnosticsWarningSign"</span>, &#123;<span class="string">"text"</span> : <span class="string">"W"</span>, <span class="string">"texthl"</span> : <span class="string">"LspDiagnosticsWarning"</span>&#125;)</span><br><span class="line"><span class="keyword">call</span> sign_define(<span class="string">"LspDiagnosticsInformationSign"</span>, &#123;<span class="string">"text"</span> : <span class="string">"I"</span>, <span class="string">"texthl"</span> : <span class="string">"LspDiagnosticsInformation"</span>&#125;)</span><br><span class="line"><span class="keyword">call</span> sign_define(<span class="string">"LspDiagnosticsHintSign"</span>, &#123;<span class="string">"text"</span> : <span class="string">"H"</span>, <span class="string">"texthl"</span> : <span class="string">"LspDiagnosticsHint"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:diagnostic_show_sign</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:diagnostic_enable_virtual_text</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:diagnostic_insert_delay</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:diagnostic_virtual_text_prefix</span> = <span class="string">'&lt;'</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<img data-src="/2020/09/03/go_neovim_env/diagnostic_demo.gif" class="">

<p>如果覺得字還沒打完就有警告很煩，可以改變此選項 <code>let g:diagnostic_insert_delay = 1</code>，則會在進入 normal mode 時進行警告。</p>
<p><code>completion-nvim</code> 範例設定：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:completion_chain_complete_list</span> = [</span><br><span class="line">            \&#123;<span class="string">'complete_items'</span>: [<span class="string">'lsp'</span>]&#125;,</span><br><span class="line">            \]</span><br></pre></td></tr></table></figure>
<p>效果</p>
<img data-src="/2020/09/03/go_neovim_env/completion_demo.gif" class="">

<p>Note: <code>nvim-lspconfig</code>, <code>completion-nvim</code>, <code>diagnostic-nvim</code> 皆不相容 vim</p>
<p>LSP 相關 Plugin： <a href="https://github.com/prabirshrestha/vim-lsp" target="_blank" rel="noopener">vim-lsp</a> (vim only), <a href="https://github.com/autozimu/LanguageClient-neovim" target="_blank" rel="noopener">LanguageClient-neovim</a> (neovim only)</p>
<p>Completion 相關 Plugin： <a href="https://github.com/ncm2/ncm2" target="_blank" rel="noopener">ncm2</a> (vim8 and neovim), <a href="https://github.com/Shougo/deoplete.nvim" target="_blank" rel="noopener">deoplete.nvim</a> (vim8 and neovim)</p>
<p>Diagnostic 相關 Plugin: <a href="https://github.com/neomake/neomake" target="_blank" rel="noopener">neomake</a> (neovim and vim8), <a href="https://github.com/dense-analysis/ale" target="_blank" rel="noopener">ale</a> (neovim and vim8)</p>
<blockquote>
<p>看了 completion-nvim 的 contribution 大部分是由 haorenW1025 大大所寫，帳號掛 NTU，台灣人寫的套件還不支持一波</p>
</blockquote>
<h1 id="Code-Outline-tagbar"><a href="#Code-Outline-tagbar" class="headerlink" title="Code Outline (tagbar)"></a>Code Outline (tagbar)</h1><img data-src="/2020/09/03/go_neovim_env/tagbar_demo.png" class="">

<p>當 code 越寫越多，一個 file 越長越大，一個 file 超過 1000 行，或超過 15 個 function，就需要一個綜觀全局的 Plugin，這當然就需要交給 <code>tagbar</code> 了。</p>
<p>另外一種情境，當你不熟你手上的這份專案時，用 <code>tagbar</code> 先進行大綱式的觀察，是再好不過的方式了</p>
<p>首先先安裝 <a href="https://github.com/jstemmer/gotags" target="_blank" rel="noopener">gotags</a>, gotags 在 Readme 上都寫好怎麼設定了。</p>
<p>安裝 Tagbar:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'majutsushi/tagbar'</span></span><br></pre></td></tr></table></figure>
<p>gotags 及 tagbar 設定：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:tagbar_type_go</span> = &#123;</span><br><span class="line">            \ <span class="string">'ctagstype'</span> : <span class="string">'go'</span>,</span><br><span class="line">            \ <span class="string">'kinds'</span>     : [</span><br><span class="line">            \ <span class="string">'p:package'</span>,</span><br><span class="line">            \ <span class="string">'i:imports:1'</span>,</span><br><span class="line">            \ <span class="string">'c:constants'</span>,</span><br><span class="line">            \ <span class="string">'v:variables'</span>,</span><br><span class="line">            \ <span class="string">'t:types'</span>,</span><br><span class="line">            \ <span class="string">'n:interfaces'</span>,</span><br><span class="line">            \ <span class="string">'w:fields'</span>,</span><br><span class="line">            \ <span class="string">'e:embedded'</span>,</span><br><span class="line">            \ <span class="string">'m:methods'</span>,</span><br><span class="line">            \ <span class="string">'r:constructor'</span>,</span><br><span class="line">            \ <span class="string">'f:functions'</span></span><br><span class="line">            \ ],</span><br><span class="line">            \ <span class="string">'sro'</span> : <span class="string">'.'</span>,</span><br><span class="line">            \ <span class="string">'kind2scope'</span> : &#123;</span><br><span class="line">            \ <span class="string">'t'</span> : <span class="string">'ctype'</span>,</span><br><span class="line">            \ <span class="string">'n'</span> : <span class="string">'ntype'</span></span><br><span class="line">            \ &#125;,</span><br><span class="line">            \ <span class="string">'scope2kind'</span> : &#123;</span><br><span class="line">            \ <span class="string">'ctype'</span> : <span class="string">'t'</span>,</span><br><span class="line">            \ <span class="string">'ntype'</span> : <span class="string">'n'</span></span><br><span class="line">            \ &#125;,</span><br><span class="line">            \ <span class="string">'ctagsbin'</span>  : <span class="string">'gotags'</span>,</span><br><span class="line">            \ <span class="string">'ctagsargs'</span> : <span class="string">'-sort -silent'</span></span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure>


<h1 id="Go-development-plugin-vim-go"><a href="#Go-development-plugin-vim-go" class="headerlink" title="Go development plugin (vim-go)"></a>Go development plugin (vim-go)</h1><p>Golang 在 vim 的開發中，不可能不提 <code>vim-go</code> 了，應該也是我在 vim plugin 看過支援完整的開發工具之一了，vim-go 設定眾多，我只挑出了我覺得最有用的幾個出來談。</p>
<p>安裝</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'fatih/vim-go'</span>,&#123;<span class="string">'for'</span>:<span class="string">'go'</span>, <span class="string">'do'</span>: <span class="string">':GoUpdateBinaries'</span>&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/golangci/golangci-lint" target="_blank" rel="noopener">golangci-lint</a> 是把不一樣的 go 語言 linter 集合起來成一包，在 teminal 打 <code>golangci-lint linters</code> 就會列出一堆 linter，挑選自己想要的 linter 放入 <code>g:go_metalinter_enabled</code> 陣列裡。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:go_metalinter_command</span> = <span class="string">"golangci-lint"</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:go_metalinter_enabled</span> = [<span class="string">'vet'</span>, <span class="string">'errcheck'</span>, <span class="string">'staticcheck'</span>, <span class="string">'gosimple'</span>]</span><br></pre></td></tr></table></figure>
<p>使用 <code>:GoMetaLinter</code> 開始對專案進行檢查。</p>
<p>當然 code 越大或是 linter 放得越多檢查越慢，所以我通常寫到一個段落才下此命令，linter 檢查完後 quickfix list 則會跳出，請看demo：</p>
<img data-src="/2020/09/03/go_neovim_env/golangci_lint_demo.gif" class="">

<p>code navigation 設定，不使用 <code>vim-go</code> 預設的 key mapping，使用自己習慣的方式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:go_def_mapping_enabled</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> gd <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-def)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> gD <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-describe)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> gR <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-<span class="built_in">rename</span>)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="keyword">gr</span> <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-referrers)</span><br></pre></td></tr></table></figure>

<p>最屌的是 vim-go 能直接跑 Testing (<code>:GoTest</code>), Debugger (<code>:GoDebugStart</code>), Run (<code>:GoRun</code>), Build (<code>:GoBuild</code>)</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;f4&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-test)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;f5&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-build)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;f6&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-run)</span><br></pre></td></tr></table></figure>

<p><code>:GoTest</code> demo：</p>
<img data-src="/2020/09/03/go_neovim_env/go_test_demo.gif" class="">

<p>vim-go 設定一定要看過 <a href="https://github.com/fatih/vim-go-tutorial" target="_blank" rel="noopener">vim-go-tutorial</a>，由 vim-go 作者提供的設定教學。</p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>如果要一個適合自己的 (neo)vim 環境，當然這篇文章只是冰山一角而已。這裡提到的 Plugin，每一個都可以開一篇文章來介紹，所以每一個 Plugin 我盡量用最簡單的範例設定，展現它的功能和精髓。另外還有 fuzzy finder, auto pair, indent line guide, snippet ..等 Plugin, 還沒提到，之後會分好幾篇文章來寫。</p>
<p>在配置設定的一開始，盡量先去抄別人的，直接看看抄了設定會發生什麼效果， 或是使用 <code>:help</code> 查詢看看。</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h1><p>要去哪裡查到別人的 vim 設定？<br>在 github 上查詢關鍵字：dotfile, dotfiles, vimrc, vim-config, nvimrc 等等的字。<br>這裡我就提供兩個大神的 vim 設定：</p>
<ul>
<li><a href="https://github.com/Shougo/shougo-s-github" target="_blank" rel="noopener">https://github.com/Shougo/shougo-s-github</a></li>
<li><a href="https://github.com/rafi/vim-config" target="_blank" rel="noopener">https://github.com/rafi/vim-config</a></li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://github.com/neovim/nvim-lspconfig" target="_blank" rel="noopener">https://github.com/neovim/nvim-lspconfig</a></li>
<li><a href="https://github.com/fatih/vim-go-tutorial" target="_blank" rel="noopener">https://github.com/fatih/vim-go-tutorial</a></li>
</ul>
]]></content>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 78 語法篇 - interface</title>
    <url>/2020/07/03/golang78syntax/</url>
    <content><![CDATA[<p>Interface 可以說是 golang 的精髓之一。golang interface 特殊的語法以及概念也是工程師常常犯錯的地方。此題只是用來釐清自己的概念。</p>
<h1 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h1><p>請問以下程式輸出結果為何</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;</span><br><span class="line">    val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">F</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IF <span class="keyword">interface</span> &#123;</span><br><span class="line">	F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitType</span><span class="params">()</span> <span class="title">S</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitPointer</span><span class="params">()</span> *<span class="title">S</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitEfaceType</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitEfacePointer</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">var</span> s *S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitIfaceType</span><span class="params">()</span> <span class="title">IF</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitIfacePointer</span><span class="params">()</span> <span class="title">IF</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// fmt.Println(InitType() == nil) // type mismatch</span></span><br><span class="line">	fmt.Println(InitPointer() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitEfaceType() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitEfacePointer() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitIfaceType() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitIfacePointer() == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <a id="more"></a>

<h1 id="回歸基本"><a href="#回歸基本" class="headerlink" title="回歸基本"></a>回歸基本</h1><p>在回答問題之前先複習什麼是 <code>Interface Satisfaction</code> 和 <code>Interface Values</code> ，分別在 The Go Programming Language 章節 7.3 和 7.5。</p>
<h2 id="Interface-Satisfaction"><a href="#Interface-Satisfaction" class="headerlink" title="Interface Satisfaction"></a>Interface Satisfaction</h2><p>直接給出書上的解釋，這兩段句子及範例程式已經淺顯易懂，不多作解釋:</p>
<p>A type <code>satisfies</code> an interface if it possesses all the methods the interface requires.</p>
<p>The assignability rule for interfaces is very simple: an expression may be assigned to an interface only if its type satisfies the interface.</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package io</span></span><br><span class="line"><span class="comment">type Writer interface &#123;</span></span><br><span class="line"><span class="comment">    Write(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout           <span class="comment">// OK: *os.File has Write method</span></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)   <span class="comment">// OK: *bytes.Buffer has Write method</span></span><br><span class="line">w = time.Second         <span class="comment">// compile error: time.Duration lacks Write method</span></span><br></pre></td></tr></table></figure>

<h2 id="Interface-Values"><a href="#Interface-Values" class="headerlink" title="Interface Values"></a>Interface Values</h2><p>The Go Programming Language 7.5 第一句開門見山地馬上給出概念:</p>
<p>Conceptually, a value of an interface type, or <code>interface value</code> has two components, a concrete type and a value of that type . These are called the interface’s <code>dynamic type</code> and <code>dynamic value</code>.</p>
<p>並且用一個例子做出了很棒的解釋:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<img data-src="/2020/07/03/golang78syntax/golang78syntax_1.jpg" class="" title="line1 - line4">

<p>另一個例子:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line"><span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">w = buf</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%v %T\n"</span>, w, w) <span class="comment">// &lt;nil&gt;  *bytes.Buffer</span></span><br><span class="line"><span class="keyword">if</span> w != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"w not nil"</span>) <span class="comment">// This line will be executed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若 <code>w != nil</code> 要成立則 <code>dynamic type</code> 和 <code>dynamic value</code> 皆為 <code>non-nil</code> 才會成立。<br>因為 w 的 dynamic value 是 <code>*bytes.Buffer</code> 不為 <code>nil</code> 所以 <code>w != nil</code> 就會成立。</p>
<img data-src="/2020/07/03/golang78syntax/golang78syntax_2.jpg" class="">

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>題目的 Line 43, 44 難度不高，直接跳過<br>剩下的看下圖</p>
<img data-src="/2020/07/03/golang78syntax/golang78syntax_3.jpg" class="">

<p>Line 50 牽扯到了 <code>method set</code> 的細節，留著下篇解釋，可以參考 Reference 1, 2</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener">https://golang.org/ref/spec#Method_sets</a></li>
<li><a href="https://stackoverflow.com/questions/33587227/method-sets-pointer-vs-value-receiver" target="_blank" rel="noopener">https://stackoverflow.com/questions/33587227/method-sets-pointer-vs-value-receiver</a></li>
</ol>
]]></content>
      <categories>
        <category>golang78 syntax series</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 78 語法篇 - method set</title>
    <url>/2020/07/07/golang78syntax2/</url>
    <content><![CDATA[<p><code>method set</code>, <code>interface</code>, <code>auto deference or reference</code> 當這些語法綜合再一起使用時，很容易混淆，甚至寫出 bug code，這章我們就透過題目探討一下 <code>method set</code> 常常被大家誤會的地方。</p>
<a href="/2020/07/03/golang78syntax/" title="Golang 78 語法篇 - interface">Golang 78 語法篇 - interface</a> Line 50 用到的概念就在這篇。


<h1 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h1><p>請問以下程式輸出結果為何</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">DoWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"do work"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	(&amp;Employee&#123;&#125;).DoWork()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案只有兩種方向:<br>    1. 無法編譯<br>    2. 印出 do work</p>
<p>這個程式可以編譯，並且還印出 do work 但是為什麼呢？</p>
 <a id="more"></a>

<h1 id="Method-set"><a href="#Method-set" class="headerlink" title="Method set"></a>Method set</h1><p>在 receiver argument 和 receiver parameter 不一樣的情況下，直覺反應就是 <code>implicit dereference</code> 和 <code>implicit reference</code> 在背後會幫忙，但是這個寫法 (struct literal) 是不會有此情況的。</p>
<p>既然沒有 <code>implicit dereference</code> 和 <code>implicit reference</code> 的支援，那一定存在其它機制使得這段 code 能正常編譯。</p>
<p>以下從 <a href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener">Golang Specification</a>所截取的句子:</p>
<p>The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T)</p>
<p>以下是從 <a href="https://golang.org/doc/faq#different_method_sets" target="_blank" rel="noopener">Golang FAQ</a> 所截取的句子:</p>
<p>As the Go specification says, the method set of a type T consists of all methods with receiver type T, while that of the corresponding pointer type *T consists of all methods with receiver *T or T. That means the method set of *T includes that of T, but not the reverse</p>
<p>其實意思就是型態 T 的所有 method 包含了所有 receiver 型態是 T 的 method，這理所當然，看起來也像廢話，另一句才是關鍵，也是今日的重點：*T 型態的所有 method 包含了 receiver 型態是 T 及 *T 的 method。</p>
<p>有了此結論我們就能知道 <code>*Employee</code> 的 method set 裡是有 <code>DoWork()</code>，所以編譯會過。</p>
<p>那這就有趣了，再看一個延伸題，請問這段 code 編譯會不會過:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Worker <span class="keyword">interface</span> &#123;</span><br><span class="line">	DoWork()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">DoWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"do work"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> w Worker = &amp;Employee&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這段 code 問的其實就是 Employee 到底有沒有符合(satisfy) <code>Worker</code> 介面，根據剛剛所得出的結論， <code>*Employee</code> 的 method set 裡是有包含 <code>DoWork</code> 的，所以編譯是會過的。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://golang.org/doc/faq#different_method_sets" target="_blank" rel="noopener">Golang Frequently Asked Questions (FAQ)</a></li>
<li><a href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener">The Go Programming Language Specification - Method sets</a></li>
</ol>
]]></content>
      <categories>
        <category>golang78 syntax series</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>誰說不能在 vim 裡編譯，從 :make 到 :Make</title>
    <url>/2020/09/10/vim-make/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回想一下，上一次使用 vim 寫 code 到一個段落要編譯時，你是怎麼做的。</p>
<p>我看到大多數人的方式，就是將 terminal 切成兩塊，一塊寫 code，一塊編譯，若編譯有錯誤，再移動到寫 code 區塊更改。<br>如果使用此方法，當專案有規模時，編譯錯誤一百條，看了編譯錯誤在哪之後，再將編譯錯誤的位置，從專案裡找出來，反覆來回 100 次，直到修正完畢。<br>本文以 C 語言專案為例 (當然不是只有 C 語言才能這樣子幹，可看 Q&amp;A)，聊聊強大的 vim 在這種情境下有什麼好的解決方案。</p>
<img data-src="/2020/09/10/vim-make/tmux_split.png" class="">
 <a id="more"></a>


<h1 id="強大的-make"><a href="#強大的-make" class="headerlink" title="強大的 :make"></a>強大的 <code>:make</code></h1><h2 id="基本款"><a href="#基本款" class="headerlink" title="基本款"></a>基本款</h2><p>此次範例就拿 neovim 來編譯好了，根據官方文件要這樣編譯 <code>make CMAKE_BUILD_TYPE=Release</code>，所以在我在 vim 裡這樣編 <code>:make CMAKE_BUILD_TYPE=Release</code></p>
<p>看起來噴了一點錯誤，案了 <code>enter</code> 似乎之後什麼事都沒發生，回到平常。</p>
<img data-src="/2020/09/10/vim-make/make_cmd.png" class="">

<p>用 <code>:cl</code> 指令，喔幹!不是一點錯誤，是一堆錯誤，沒列出來根本不知道。</p>
<img data-src="/2020/09/10/vim-make/clist_cmd.png" class="">

<p>重點來了!! 可以使用 <code>:cn</code> (<code>:cnext</code>) 跳到下一個錯誤位置，<code>:cp</code> (<code>:cprevious</code>) 跳轉到上一個錯誤位置，就不需要自己手動一個一個錯誤找出來。<br>看上圖，可以觀察到，每一條錯誤前面都有一個數字，如果想要跳到特定錯誤去修那就使用 <code>:cc [number]</code>，跳轉到第一個錯誤就用 <code>:cc 12</code>，跳轉到第三個錯誤就用 <code>:cc 19</code>。</p>
<p>火力展示:</p>
<img data-src="/2020/09/10/vim-make/clist_demo.gif" class="">

<p>總結一下指令:</p>
<ul>
<li><code>:make</code>: 執行 makefile</li>
<li><code>:cl</code>: 列出所有錯誤</li>
<li><code>:cn</code>: 跳到下個錯誤</li>
<li><code>:cp</code>: 跳到上個錯誤</li>
<li><code>:cc [number]</code>: 跳轉到特定錯誤</li>
</ul>
<h2 id="如虎添翼的-quickfix-window"><a href="#如虎添翼的-quickfix-window" class="headerlink" title="如虎添翼的 quickfix-window"></a>如虎添翼的 quickfix-window</h2><p>編譯完之後，除了用 <code>:cl</code> 查看，另一種方式就是用 <code>:copen</code>，打下此指令之後，將會彈出 quickfix-window，列出的錯誤其實就是 <code>:clist</code> 的詳細版本， quickfix-window 只是提供了一種查找的方式。</p>
<img data-src="/2020/09/10/vim-make/copen_cmd.png" class="">
<p>移轉到 quickfix-window 後，移動到想要查看的錯誤，案 <code>enter</code> 即可跳轉到該錯誤位置，當然也能配合 <code>:cn</code>, <code>:cp</code>, <code>:cc [number]</code>，quickfix-window 會配合這些指令連動顯示目前位置。</p>
<p>Note: 詳見 <code>:help quickfix-window</code></p>
<h1 id="讓你飛起來的-vim-dispatch"><a href="#讓你飛起來的-vim-dispatch" class="headerlink" title="讓你飛起來的 vim-dispatch"></a>讓你飛起來的 vim-dispatch</h1><p>使用 vim 內建的 <code>:make</code> 指令，在編譯時其實是會 block 整個 vim 的，若專案夠大編譯很久，那段時間什麼都不能做，只能看著他編譯，vim-dispatch 完美解決了這個問題。</p>
<p>安裝:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plug &#39;tpope&#x2F;vim-dispatch&#39;</span><br></pre></td></tr></table></figure>

<p>其實 vim-dispatch 用法很簡單，<code>:Make</code> 編譯，<code>:Copen</code> 打開 quickfix-window，當然也能配合剛剛所提到的跳轉指令使用，幾乎完美配合 vim 的使用習慣。</p>
<p>當然 vim-dispatch 不只這樣而已，其他功能不在本篇範圍，詳情請見 vim-dispatch 的文件。</p>
<p>火力展示，可以看到上方的視窗可以移動 cursor，下方則繼續編譯:</p>
<img data-src="/2020/09/10/vim-make/Make_demo.gif" class="">

<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h1><h2 id="vim-使用-make-指令，那不是只有寫-Makefile-才能用嗎"><a href="#vim-使用-make-指令，那不是只有寫-Makefile-才能用嗎" class="headerlink" title="vim 使用 :make 指令，那不是只有寫 Makefile 才能用嗎?"></a>vim 使用 <code>:make</code> 指令，那不是只有寫 Makefile 才能用嗎?</h2><p>當然在想在其他語言使用 <code>:make</code> 指令，達到一樣效果就要編寫客製化的 plugin 了，當然很受歡迎的語言都有人寫好啦，通常都是包在語言 plugin 裡：</p>
<ul>
<li><a href="https://github.com/rust-lang/rust.vim" target="_blank" rel="noopener">rust.vim</a>: 原本編譯方式是 <code>cargo build</code>，在 vim 裡變成 <code>:make build</code> 就好，以此類推可以 <code>:make run</code></li>
<li><a href="https://github.com/fatih/vim-go" target="_blank" rel="noopener">vim-go</a>:在 vim-go 可以使用 <code>:GoBuild</code>, <code>:GoRun</code></li>
</ul>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>vim 是一個古老的編輯器，某些特色和 C 語言沾上關係，比如說 make 指令 (或許當年 C 語言獨佔天下!?)，當然 vim 不只可以使用 make 這種自動化編譯，vim 也開放了幾個 api 使得再起他語言也能達成一樣的效果 (詳見 <code>:help makeprg</code>)，在專案愈大時愈能顯現其效果，當年我也是碰了一點 linux kernel，才學習到這個技巧，加速了不少開發速度。</p>
<p>如果有什麼相關技巧，歡迎在底下留言交流。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.ptt.cc/bbs/Editor/M.1285722960.A.BF5.html" target="_blank" rel="noopener">Re: [轉錄][問題] VIM 編譯與執行</a></li>
<li>vim help doc</li>
</ul>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊 vim mark 使用情境 - code 參照</title>
    <url>/2020/09/07/vim-mark-tips/</url>
    <content><![CDATA[<img data-src="/2020/09/07/vim-mark-tips/cover.png" class="">
<p>寫程式的時候常常遇到一種情況，假設你是團隊的新人，需要常常參照別人的程式，看看團隊的 coding style 等等，可能需要參照 A file 的第 10 行，B file 第 8 行，C file 第 999 行。</p>
<p>另一種情境則是在寫測試的時候會和實作交互參照，而測試程式往往和實作程式會拆開不同的檔案，所以就必須要一直跳轉。</p>
<p>使用 split 的方式縱然是一個不錯的方式，但是如果要參照的點大於三個，就將螢幕切成三份，那工程師就相當痛苦了，不是每個人都用這種電腦螢幕啊。這種 split 的方式還有另一個缺點：如果手殘將檔案關掉，就得重找。</p>
<img data-src="/2020/09/07/vim-mark-tips/cj890.jpg" class="">

 <a id="more"></a>

<h1 id="Mark"><a href="#Mark" class="headerlink" title="Mark"></a>Mark</h1><p>vim 的 mark 取名或許源自於 bookmark (書籤) 這個字，書籤的用意在於能快速找回你上次看的那一頁，而 vim mark 的用意也是如此：能快速找回你剛剛在看 code 的地方。</p>
<p>vim 的 mark 分為三種：</p>
<ul>
<li>Local mark <code>a-z</code>： 每一個 file 裡皆有自己的 local mark，也就是說檔案 A 可以有 mark a, 檔案 B 裡也可以有自己的 mark a</li>
<li>Global mark <code>A-Z</code>： 此種 mark 是全域的，也就是說在檔案 A 裡所看到的 mark A 和 B 檔案 B 裡的 mark A 是一樣的</li>
<li>Special mark：其他神奇的 mark，不在此文章討論範圍</li>
</ul>
<p>mark 的基本使用：</p>
<ul>
<li><code>ma</code>： 在這個地方設置 mark a</li>
<li><code>mA</code>： 在這個地方設置 mark A</li>
<li><code>&#39;a</code>： 跳到 mark a 的這行 (此行的第一個非空白字元)</li>
<li><code>`a</code>： 精準的跳到你當初設置 mark a 的位置 (第幾行第幾列)</li>
<li><code>:marks</code>： 列出來所有 mark，有時候 mark 設置太多會忘</li>
</ul>
<p>更多詳細操作請參照 Reference 3</p>
<h1 id="回到正題"><a href="#回到正題" class="headerlink" title="回到正題"></a>回到正題</h1><p>還記得一開始的情境敘述嗎？<br>雖然你已經知道要在 A file 第 10 行 <code>mA</code>， 在 B file 第 8 行 <code>mB</code>，C file 第 999 行 <code>mC</code>。</p>
<p>實際上在寫 code 時我會這樣做：</p>
<ul>
<li>我會先將我需要參照的地方找出並且 mark，以剛剛的例子來說就是在 A file 第 10 行 <code>mA</code> 在 B file 第 8 行 <code>mB</code>，C file 第 999 行 <code>mC</code></li>
<li>使用 <code>:vsplit</code> 將螢幕切成兩邊，左邊寫 code，右邊當參照區域</li>
<li>需要參照 B 這個位置時，移動到參照區域 ，<code>&#39;B</code> 再移動回寫 code 區域繼續寫</li>
</ul>
<img data-src="/2020/09/07/vim-mark-tips/mark_show.png" class="">

<p>那 local mark 什麼時候用？<br>當一個檔案大於 1000 行，寫的程式在 1001 行，但你需要參照的程式在第一行，也就是都在同一個 file 跳轉的時候可以使用。</p>
<h1 id="search-小技巧"><a href="#search-小技巧" class="headerlink" title="search 小技巧"></a>search 小技巧</h1><p>每次在使用 <code>/</code> 搜尋一定會案 <code>n</code> 或 <code>N</code> 到處跳轉，尋找目標，常常找完了之後，忘記我原本的地方在哪了，此時就能先用 mark 記住後在開始用 <code>/</code> 查找。<br>由於常使用這種操作，所以直接這樣：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> / ms/</span><br></pre></td></tr></table></figure>
<p> 在<code>/</code>搜尋完後，要跳回原本的地方就 <code>&#39;s</code> 就好</p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>人類總是會在大量的資料中迷失，並且花上很多時間查找和記憶，標記(或是書籤)就是其中一種解決方案，而且應用不只在書上，到處都可以看到類似的應用，像是檔案夾的標籤、英文書在最後會有的索引，然而在寫程式上也不例外。不管是在寫 code 上還是其他應用，好好的應用這些工具將能事半功倍。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://medium.com/usevim/vim-101-marks-caad7106b241" target="_blank" rel="noopener">https://medium.com/usevim/vim-101-marks-caad7106b241</a></li>
<li><a href="https://medium.com/usevim/vim-101-practicing-marks-fc5778d8aaea" target="_blank" rel="noopener">https://medium.com/usevim/vim-101-practicing-marks-fc5778d8aaea</a></li>
<li><a href="https://vim.fandom.com/wiki/Using_marks" target="_blank" rel="noopener">https://vim.fandom.com/wiki/Using_marks</a></li>
</ol>
]]></content>
      <tags>
        <tag>vim</tag>
        <tag>neovim</tag>
      </tags>
  </entry>
</search>

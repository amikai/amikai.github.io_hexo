<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang 開發環境 - 使用 neovim</title>
    <url>/2020/09/03/go_neovim_env/</url>
    <content><![CDATA[<img data-src="/2020/09/03/go_neovim_env/cover.png" class="">

<h1 id="你確定要用-neovim-開發-golang"><a href="#你確定要用-neovim-開發-golang" class="headerlink" title="你確定要用 neovim 開發 golang?"></a>你確定要用 neovim 開發 golang?</h1><p>現在是 vscode 稱霸天下的時代，理所當然的 (neo)vim 也常常被拿來 vscode 比較，vscode 內建整合了 git、debugger、自動補全引擎、terminal、extension manager，另外 Golang 在 vscode 上的 extension 支援相當良好: 包括跳轉到定義 (go to definition)、重新命名 (rename)、跳轉到型態定義 (go to type definition)⋯⋯ 一堆細節功能，近期由於 google golang team 接手 go 語言的 vscode extension，相信使用 vscode 開發是不錯的選擇。</p>
<p> (neo)vim 當然也能達到 vscode 的類似功能，但是必須花時間設定調教，在 vscode 問世之前我會推薦 (Neo)vim 給我的朋友，vscode 問世之後我就開始推薦 vscode。</p>
<blockquote>
<p>本文給那些本來就在 (neo)vim 裡打滾的人，但對 go 語言設定不熟的人，<br>如果你是一張白紙，而且沒有被虐的癖好，我建議選擇 vscode，可以用較少的時間進入到寫程式的環節，而不是一直在花時間在設定，這篇文你也沒必要看下去。</p>
</blockquote>
<h1 id="預備動作"><a href="#預備動作" class="headerlink" title="預備動作"></a>預備動作</h1><p>Must have</p>
<ul>
<li>你應該先安裝好 neovim nightly 版本，<code>brew install neovim --HEAD</code></li>
<li>你應該要知道怎麼使用 vim-plug，至少要知道 <code>:PlugInstall</code></li>
<li>你應該先把 go 語言環境安裝好</li>
</ul>
<p>Nice to have</p>
<ul>
<li>你知道 <code>:checkhealth</code> 和 <code>:UpdateRemotePlugin</code></li>
<li>你收悉 <code>:help</code> 的使用方式，這裡有一篇好文：<a href="https://vim.fandom.com/wiki/Learn_to_use_help" target="_blank" rel="noopener">Learn to use help</a></li>
</ul>
<h1 id="開發環境基本功能"><a href="#開發環境基本功能" class="headerlink" title="開發環境基本功能"></a>開發環境基本功能</h1><p>一個好用的 Editor 我認為應該包含以下幾點基本功能:</p>
<ul>
<li>Auto completion - 好的自動補全引擎</li>
<li>File manager - 可以在側邊欄看到專案的結構</li>
<li>Real time linter - 在寫 code 犯錯的同時，有一些提示 (也就是 diagnostic 功能)</li>
<li>Background compile - 編譯的同時不應該卡住整個 Editor，要讓使用者能做其他事情</li>
<li>Code navigation: 包含跳轉到定義，跳轉到型態定義，或是當一個檔案寫得很長的時候，怎麼綜觀全局</li>
</ul>
<p>以下我將會介紹我使用的 Plugin，達到我上述所提到的功能。<br>以下使用的皆是 Neovim nightly 版本，使用 stable 是沒有官方 LSP 支援的。</p>
<p>Note：neovim 是由 vim 所 fork 出來的，差異介紹請看<a href="https://kerol2r20.github.io/post/2017-10-29-neovim-introdunction/" target="_blank" rel="noopener">這篇</a>，某些 Plugin 不會同時相容於兩者，我接會標明。</p>
<h1 id="File-explorer-defx-nvim"><a href="#File-explorer-defx-nvim" class="headerlink" title="File explorer (defx.nvim)"></a>File explorer (defx.nvim)</h1><img data-src="/2020/09/03/go_neovim_env/defx.png" class="">

<p>為什麼不用老牌的 nerdtree 就好，要使用別的 file explorer，<br>沒辦法 nerdtree 就是慢，只要專案稍微有一點規模，就會有明顯的卡頓。</p>
<p>defx 由 python3 寫成，是一個需要高度手動設定的 file explorer，不像 nerdtree 幾乎可以開箱及用，在設定時一定得查看 defx 的 help 文件，裡頭有相當多設定範例。</p>
<p>為了讓 neovim 知道 python3 在哪，將此行寫入 vimrc：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:python3_host_prog</span> = <span class="string">'/path/to/python3'</span></span><br></pre></td></tr></table></figure>
<p>設定完此行之行 執行 <code>:checkhealth</code>，neovim 就會開始查看有沒有抓到 python3</p>
<p>安裝</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'Shougo/defx.nvim'</span></span><br></pre></td></tr></table></figure>
<p>安裝完後執行 <code>:UpdateRemotePlugins</code></p>
<p>使用 F4 映射到 defx</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;F4&gt;</span> <span class="symbol">&lt;cmd&gt;</span>Defx -<span class="keyword">buffer</span>-name=<span class="string">"defx"</span><span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<p>外觀設定</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> defx#custom#column(<span class="string">'icon'</span>, &#123;</span><br><span class="line">            \ <span class="string">'directory_icon'</span>: <span class="string">'▸'</span>,</span><br><span class="line">            \ <span class="string">'opened_icon'</span>: <span class="string">'▾'</span>,</span><br><span class="line">            \ <span class="string">'root_icon'</span>: <span class="string">'📁 '</span>,</span><br><span class="line">            \ &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> defx#custom#column(<span class="string">'filename'</span>, &#123;</span><br><span class="line">            \ <span class="string">'min_width'</span>: <span class="number">128</span>,</span><br><span class="line">            \ <span class="string">'max_width'</span>: <span class="number">128</span>,</span><br><span class="line">            \ &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> defx#custom#option(<span class="string">'_'</span>, &#123;</span><br><span class="line">            \ <span class="string">'columns'</span>: <span class="string">'mark:indent:icon:filename:type'</span>,</span><br><span class="line">            \ <span class="string">'split'</span>: <span class="string">'vertical'</span>,</span><br><span class="line">            \ <span class="string">'winwidth'</span>: <span class="number">35</span>,</span><br><span class="line">            \ <span class="string">'direction'</span>: <span class="string">'topleft'</span>,</span><br><span class="line">            \ <span class="string">'resume'</span>: <span class="variable">v:false</span>,</span><br><span class="line">            \ <span class="string">'toggle'</span>: <span class="variable">v:true</span></span><br><span class="line">            \ &#125;)</span><br></pre></td></tr></table></figure>

<p>使用 enter 打開或關閉資料夾：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;buffer&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;CR&gt;</span></span><br><span class="line">            \ defx#is_directory() ?</span><br><span class="line">            \ defx#do_action(<span class="string">'open_or_close_tree'</span>) :</span><br><span class="line">            \ defx#do_action(<span class="string">'drop'</span>)</span><br></pre></td></tr></table></figure>


<p>因為 defx 的高度彈性，以及舊有的 nerdtree使用習慣，所以我就把 defx 的 key mapping 設定成類似 nerdtree，這裡就只做基本設定，以後有空會多開一篇詳細講 defx 設定，如果有興趣請參考<a href="https://github.com/amikai/nvimrc/blob/46d4c73f9e/config/defx.vim" target="_blank" rel="noopener">我的設定</a> </p>
<p>Note: defx (neovim only)</p>
<p>類似 Plugin: <a href="https://github.com/preservim/nerdtree" target="_blank" rel="noopener">nerdtree</a> (vim and neovim), <a href="https://github.com/justinmk/vim-dirvish" target="_blank" rel="noopener">vim-dirvish</a> (vim and neovim)</p>
<h1 id="Auto-completion-completion-nvim-amp-diagnostic-diagnostic-nvim"><a href="#Auto-completion-completion-nvim-amp-diagnostic-diagnostic-nvim" class="headerlink" title="Auto completion (completion-nvim) &amp; diagnostic (diagnostic-nvim)"></a>Auto completion (completion-nvim) &amp; diagnostic (diagnostic-nvim)</h1><p>completion-nvim 和 diagnostic-nvim 都是基於 nvim-lspconfig 的 Plugin，<br>可以把 nvim-lspconfig 當成和 language server 溝通的基礎設施，Golang 預設的 language server 當然就是 gopls 啦</p>
<p>安裝</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'neovim/nvim-lspconfig'</span></span><br><span class="line">Plug <span class="string">'nvim-lua/diagnostic-nvim'</span></span><br><span class="line">Plug <span class="string">'nvim-lua/completion-nvim'</span></span><br></pre></td></tr></table></figure>

<p>在 lsp client 時，啟動 <code>completion-nvim</code> 和 <code>diagnostic-nvim</code>：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">lua &lt;&lt; EOF</span><br><span class="line">    <span class="keyword">local</span> nvim_lsp = <span class="built_in">require</span><span class="string">'nvim_lsp'</span></span><br><span class="line">    <span class="keyword">local</span> on_attach_vim = <span class="function"><span class="keyword">function</span><span class="params">(client, bufnr)</span></span></span><br><span class="line">        <span class="built_in">require</span><span class="string">'completion'</span>.on_attach(client, bufnr)</span><br><span class="line">        <span class="built_in">require</span><span class="string">'diagnostic'</span>.on_attach(client, bufnr)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    nvim_lsp.gopls.setup&#123;</span><br><span class="line">        on_attach=on_attach_vim</span><br><span class="line">    &#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><code>diagnostic-nvim</code> 範例設定：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> sign_define(<span class="string">"LspDiagnosticsErrorSign"</span>, &#123;<span class="string">"text"</span> : <span class="string">"E"</span>, <span class="string">"texthl"</span> : <span class="string">"LspDiagnosticsError"</span>&#125;)</span><br><span class="line"><span class="keyword">call</span> sign_define(<span class="string">"LspDiagnosticsWarningSign"</span>, &#123;<span class="string">"text"</span> : <span class="string">"W"</span>, <span class="string">"texthl"</span> : <span class="string">"LspDiagnosticsWarning"</span>&#125;)</span><br><span class="line"><span class="keyword">call</span> sign_define(<span class="string">"LspDiagnosticsInformationSign"</span>, &#123;<span class="string">"text"</span> : <span class="string">"I"</span>, <span class="string">"texthl"</span> : <span class="string">"LspDiagnosticsInformation"</span>&#125;)</span><br><span class="line"><span class="keyword">call</span> sign_define(<span class="string">"LspDiagnosticsHintSign"</span>, &#123;<span class="string">"text"</span> : <span class="string">"H"</span>, <span class="string">"texthl"</span> : <span class="string">"LspDiagnosticsHint"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:diagnostic_show_sign</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:diagnostic_enable_virtual_text</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:diagnostic_insert_delay</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:diagnostic_virtual_text_prefix</span> = <span class="string">'&lt;'</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<img data-src="/2020/09/03/go_neovim_env/diagnostic_demo.gif" class="">

<p>如果覺得字還沒打完就有警告很煩，可以改變此選項 <code>let g:diagnostic_insert_delay = 1</code>，則會在進入 normal mode 時進行警告。</p>
<p><code>completion-nvim</code> 範例設定：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:completion_chain_complete_list</span> = [</span><br><span class="line">            \&#123;<span class="string">'complete_items'</span>: [<span class="string">'lsp'</span>]&#125;,</span><br><span class="line">            \]</span><br></pre></td></tr></table></figure>
<p>效果</p>
<img data-src="/2020/09/03/go_neovim_env/completion_demo.gif" class="">

<p>Note: <code>nvim-lspconfig</code>, <code>completion-nvim</code>, <code>diagnostic-nvim</code> 皆不相容 vim</p>
<p>LSP 相關 Plugin： <a href="https://github.com/prabirshrestha/vim-lsp" target="_blank" rel="noopener">vim-lsp</a> (vim only), <a href="https://github.com/autozimu/LanguageClient-neovim" target="_blank" rel="noopener">LanguageClient-neovim</a> (neovim only)</p>
<p>Completion 相關 Plugin： <a href="https://github.com/ncm2/ncm2" target="_blank" rel="noopener">ncm2</a> (vim8 and neovim), <a href="https://github.com/Shougo/deoplete.nvim" target="_blank" rel="noopener">deoplete.nvim</a> (vim8 and neovim)</p>
<p>Diagnostic 相關 Plugin: <a href="https://github.com/neomake/neomake" target="_blank" rel="noopener">neomake</a> (neovim and vim8), <a href="https://github.com/dense-analysis/ale" target="_blank" rel="noopener">ale</a> (neovim and vim8)</p>
<blockquote>
<p>看了 completion-nvim 的 contribution 大部分是由 haorenW1025 大大所寫，帳號掛 NTU，台灣人寫的套件還不支持一波</p>
</blockquote>
<h1 id="Code-Outline-tagbar"><a href="#Code-Outline-tagbar" class="headerlink" title="Code Outline (tagbar)"></a>Code Outline (tagbar)</h1><img data-src="/2020/09/03/go_neovim_env/tagbar_demo.png" class="">

<p>當 code 越寫越多，一個 file 越長越大，一個 file 超過 1000 行，或超過 15 個 function，就需要一個綜觀全局的 Plugin，這當然就需要交給 <code>tagbar</code> 了。</p>
<p>另外一種情境，當你不熟你手上的這份專案時，用 <code>tagbar</code> 先進行大綱式的觀察，是再好不過的方式了</p>
<p>首先先安裝 <a href="https://github.com/jstemmer/gotags" target="_blank" rel="noopener">gotags</a>, gotags 在 Readme 上都寫好怎麼設定了。</p>
<p>安裝 Tagbar:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'majutsushi/tagbar'</span></span><br></pre></td></tr></table></figure>
<p>gotags 及 tagbar 設定：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:tagbar_type_go</span> = &#123;</span><br><span class="line">            \ <span class="string">'ctagstype'</span> : <span class="string">'go'</span>,</span><br><span class="line">            \ <span class="string">'kinds'</span>     : [</span><br><span class="line">            \ <span class="string">'p:package'</span>,</span><br><span class="line">            \ <span class="string">'i:imports:1'</span>,</span><br><span class="line">            \ <span class="string">'c:constants'</span>,</span><br><span class="line">            \ <span class="string">'v:variables'</span>,</span><br><span class="line">            \ <span class="string">'t:types'</span>,</span><br><span class="line">            \ <span class="string">'n:interfaces'</span>,</span><br><span class="line">            \ <span class="string">'w:fields'</span>,</span><br><span class="line">            \ <span class="string">'e:embedded'</span>,</span><br><span class="line">            \ <span class="string">'m:methods'</span>,</span><br><span class="line">            \ <span class="string">'r:constructor'</span>,</span><br><span class="line">            \ <span class="string">'f:functions'</span></span><br><span class="line">            \ ],</span><br><span class="line">            \ <span class="string">'sro'</span> : <span class="string">'.'</span>,</span><br><span class="line">            \ <span class="string">'kind2scope'</span> : &#123;</span><br><span class="line">            \ <span class="string">'t'</span> : <span class="string">'ctype'</span>,</span><br><span class="line">            \ <span class="string">'n'</span> : <span class="string">'ntype'</span></span><br><span class="line">            \ &#125;,</span><br><span class="line">            \ <span class="string">'scope2kind'</span> : &#123;</span><br><span class="line">            \ <span class="string">'ctype'</span> : <span class="string">'t'</span>,</span><br><span class="line">            \ <span class="string">'ntype'</span> : <span class="string">'n'</span></span><br><span class="line">            \ &#125;,</span><br><span class="line">            \ <span class="string">'ctagsbin'</span>  : <span class="string">'gotags'</span>,</span><br><span class="line">            \ <span class="string">'ctagsargs'</span> : <span class="string">'-sort -silent'</span></span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure>


<h1 id="Go-development-plugin-vim-go"><a href="#Go-development-plugin-vim-go" class="headerlink" title="Go development plugin (vim-go)"></a>Go development plugin (vim-go)</h1><p>Golang 在 vim 的開發中，不可能不提 <code>vim-go</code> 了，應該也是我在 vim plugin 看過支援完整的開發工具之一了，vim-go 設定眾多，我只挑出了我覺得最有用的幾個出來談。</p>
<p>安裝</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'fatih/vim-go'</span>,&#123;<span class="string">'for'</span>:<span class="string">'go'</span>, <span class="string">'do'</span>: <span class="string">':GoUpdateBinaries'</span>&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/golangci/golangci-lint" target="_blank" rel="noopener">golangci-lint</a> 是把不一樣的 go 語言 linter 集合起來成一包，在 teminal 打 <code>golangci-lint linters</code> 就會列出一堆 linter，挑選自己想要的 linter 放入 <code>g:go_metalinter_enabled</code> 陣列裡。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:go_metalinter_command</span> = <span class="string">"golangci-lint"</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:go_metalinter_enabled</span> = [<span class="string">'vet'</span>, <span class="string">'errcheck'</span>, <span class="string">'staticcheck'</span>, <span class="string">'gosimple'</span>]</span><br></pre></td></tr></table></figure>
<p>使用 <code>:GoMetaLinter</code> 開始對專案進行檢查。</p>
<p>當然 code 越大或是 linter 放得越多檢查越慢，所以我通常寫到一個段落才下此命令，linter 檢查完後 quickfix list 則會跳出，請看demo：</p>
<img data-src="/2020/09/03/go_neovim_env/golangci_lint_demo.gif" class="">

<p>code navigation 設定，不使用 <code>vim-go</code> 預設的 key mapping，使用自己習慣的方式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:go_def_mapping_enabled</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> gd <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-def)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> gD <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-describe)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> gR <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-<span class="built_in">rename</span>)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="keyword">gr</span> <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-referrers)</span><br></pre></td></tr></table></figure>

<p>最屌的是 vim-go 能直接跑 Testing (<code>:GoTest</code>), Debugger (<code>:GoDebugStart</code>), Run (<code>:GoRun</code>), Build (<code>:GoBuild</code>)</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;f4&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-test)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;f5&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-build)</span><br><span class="line"><span class="keyword">autocmd</span> Filetype <span class="keyword">go</span> <span class="keyword">nmap</span> <span class="symbol">&lt;buffer&gt;</span> <span class="symbol">&lt;f6&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(<span class="keyword">go</span>-run)</span><br></pre></td></tr></table></figure>

<p><code>:GoTest</code> demo：</p>
<img data-src="/2020/09/03/go_neovim_env/go_test_demo.gif" class="">

<p>vim-go 設定一定要看過 <a href="https://github.com/fatih/vim-go-tutorial" target="_blank" rel="noopener">vim-go-tutorial</a>，由 vim-go 作者提供的設定教學。</p>
<h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>如果要一個適合自己的 (neo)vim 環境，當然這篇文章只是冰山一角而已。這裡提到的 Plugin，每一個都可以開一篇文章來介紹，所以每一個 Plugin 我盡量用最簡單的範例設定，展現它的功能和精髓。另外還有 fuzzy finder, auto pair, indent line guide, snippet ..等 Plugin, 還沒提到，之後會分好幾篇文章來寫。</p>
<p>在配置設定的一開始，盡量先去抄別人的，直接看看抄了設定會發生什麼效果， 或是使用 <code>:help</code> 查詢看看。</p>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h1><p>要去哪裡查到別人的 vim 設定？<br>在 github 上查詢關鍵字：dotfile, dotfiles, vimrc, vim-config, nvimrc 等等的字。<br>這裡我就提供兩個大神的 vim 設定：</p>
<ul>
<li><a href="https://github.com/Shougo/shougo-s-github" target="_blank" rel="noopener">https://github.com/Shougo/shougo-s-github</a></li>
<li><a href="https://github.com/rafi/vim-config" target="_blank" rel="noopener">https://github.com/rafi/vim-config</a></li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://github.com/neovim/nvim-lspconfig" target="_blank" rel="noopener">https://github.com/neovim/nvim-lspconfig</a></li>
<li><a href="https://github.com/fatih/vim-go-tutorial" target="_blank" rel="noopener">https://github.com/fatih/vim-go-tutorial</a></li>
</ul>
]]></content>
      <tags>
        <tag>vimrc</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 78 語法篇 - method set</title>
    <url>/2020/07/07/golang78syntax2/</url>
    <content><![CDATA[<p><code>method set</code>, <code>interface</code>, <code>auto deference or reference</code> 當這些語法綜合再一起使用時，很容易混淆，甚至寫出 bug code，這章我們就透過題目探討一下 <code>method set</code> 常常被大家誤會的地方。</p>
<p><a href="golang78syntax.md">Golang 78 語法篇 - interface</a>  <code>Line 50</code> 的概念就在這篇。</p>
<h1 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h1><p>請問以下程式輸出結果為何</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">DoWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"do work"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	(&amp;Employee&#123;&#125;).DoWork()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案只有兩種方向:<br>    1. 無法編譯<br>    2. 印出 do work</p>
<p>這個程式可以編譯，並且還印出 do work 但是為什麼呢？</p>
 <a id="more"></a>

<h1 id="Method-set"><a href="#Method-set" class="headerlink" title="Method set"></a>Method set</h1><p>在 receiver argument 和 receiver parameter 不一樣的情況下，直覺反應就是 <code>implicit dereference</code> 和 <code>implicit reference</code> 在背後會幫忙，但是這個寫法 (struct literal) 是不會有此情況的。</p>
<p>既然沒有 <code>implicit dereference</code> 和 <code>implicit reference</code> 的支援，那一定存在其它機制使得這段 code 能正常編譯。</p>
<p>以下從 <a href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener">Golang Specification</a>所截取的句子:</p>
<p>The method set of the corresponding pointer type *T is the set of all methods declared with receiver *T or T (that is, it also contains the method set of T)</p>
<p>以下是從 <a href="https://golang.org/doc/faq#different_method_sets" target="_blank" rel="noopener">Golang FAQ</a> 所截取的句子:</p>
<p>As the Go specification says, the method set of a type T consists of all methods with receiver type T, while that of the corresponding pointer type *T consists of all methods with receiver *T or T. That means the method set of *T includes that of T, but not the reverse</p>
<p>其實意思就是型態 T 的所有 method 包含了所有 receiver 型態是 T 的 method，這理所當然，看起來也像廢話，另一句才是關鍵，也是今日的重點：*T 型態的所有 method 包含了 receiver 型態是 T 及 *T 的 method。</p>
<p>有了此結論我們就能知道 <code>*Employee</code> 的 method set 裡是有 <code>DoWork()</code>，所以編譯會過。</p>
<p>那這就有趣了，再看一個延伸題，請問這段 code 編譯會不會過:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Worker <span class="keyword">interface</span> &#123;</span><br><span class="line">	DoWork()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">DoWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"do work"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> w Worker = &amp;Employee&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這段 code 問的其實就是 Employee 到底有沒有符合(satisfy) <code>Worker</code> 介面，根據剛剛所得出的結論， <code>*Employee</code> 的 method set 裡是有包含 <code>DoWork</code> 的，所以編譯是會過的。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://golang.org/doc/faq#different_method_sets" target="_blank" rel="noopener">Golang Frequently Asked Questions (FAQ)</a></li>
<li><a href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener">The Go Programming Language Specification - Method sets</a></li>
</ol>
]]></content>
      <categories>
        <category>golang78 syntax series</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 78 語法篇 - interface</title>
    <url>/2020/07/03/golang78syntax/</url>
    <content><![CDATA[<p>Interface 可以說是 golang 的精髓之一。golang interface 特殊的語法以及概念也是工程師常常犯錯的地方。此題只是用來釐清自己的概念。</p>
<h1 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h1><p>請問以下程式輸出結果為何</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;</span><br><span class="line">    val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">F</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IF <span class="keyword">interface</span> &#123;</span><br><span class="line">	F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitType</span><span class="params">()</span> <span class="title">S</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitPointer</span><span class="params">()</span> *<span class="title">S</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitEfaceType</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitEfacePointer</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">var</span> s *S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitIfaceType</span><span class="params">()</span> <span class="title">IF</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitIfacePointer</span><span class="params">()</span> <span class="title">IF</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s *S</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// fmt.Println(InitType() == nil) // type mismatch</span></span><br><span class="line">	fmt.Println(InitPointer() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitEfaceType() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitEfacePointer() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitIfaceType() == <span class="literal">nil</span>)</span><br><span class="line">	fmt.Println(InitIfacePointer() == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <a id="more"></a>

<h1 id="回歸基本"><a href="#回歸基本" class="headerlink" title="回歸基本"></a>回歸基本</h1><p>在回答問題之前先複習什麼是 <code>Interface Satisfaction</code> 和 <code>Interface Values</code> ，分別在 The Go Programming Language 章節 7.3 和 7.5。</p>
<h2 id="Interface-Satisfaction"><a href="#Interface-Satisfaction" class="headerlink" title="Interface Satisfaction"></a>Interface Satisfaction</h2><p>直接給出書上的解釋，這兩段句子及範例程式已經淺顯易懂，不多作解釋:</p>
<p>A type <code>satisfies</code> an interface if it possesses all the methods the interface requires.</p>
<p>The assignability rule for interfaces is very simple: an expression may be assigned to an interface only if its type satisfies the interface.</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package io</span></span><br><span class="line"><span class="comment">type Writer interface &#123;</span></span><br><span class="line"><span class="comment">    Write(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout           <span class="comment">// OK: *os.File has Write method</span></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)   <span class="comment">// OK: *bytes.Buffer has Write method</span></span><br><span class="line">w = time.Second         <span class="comment">// compile error: time.Duration lacks Write method</span></span><br></pre></td></tr></table></figure>

<h2 id="Interface-Values"><a href="#Interface-Values" class="headerlink" title="Interface Values"></a>Interface Values</h2><p>The Go Programming Language 7.5 第一句開門見山地馬上給出概念:</p>
<p>Conceptually, a value of an interface type, or <code>interface value</code> has two components, a concrete type and a value of that type . These are called the interface’s <code>dynamic type</code> and <code>dynamic value</code>.</p>
<p>並且用一個例子做出了很棒的解釋:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<img data-src="/2020/07/03/golang78syntax/golang78syntax_1.jpg" class="" title="line1 - line4">

<p>另一個例子:</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line"><span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">w = buf</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%v %T\n"</span>, w, w) <span class="comment">// &lt;nil&gt;  *bytes.Buffer</span></span><br><span class="line"><span class="keyword">if</span> w != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"w not nil"</span>) <span class="comment">// This line will be executed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若 <code>w != nil</code> 要成立則 <code>dynamic type</code> 和 <code>dynamic value</code> 皆為 <code>non-nil</code> 才會成立。<br>因為 w 的 dynamic value 是 <code>*bytes.Buffer</code> 不為 <code>nil</code> 所以 <code>w != nil</code> 就會成立。</p>
<img data-src="/2020/07/03/golang78syntax/golang78syntax_2.jpg" class="">

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>題目的 Line 43, 44 難度不高，直接跳過<br>剩下的看下圖</p>
<img data-src="/2020/07/03/golang78syntax/golang78syntax_3.jpg" class="">

<p>Line 50 牽扯到了 <code>method set</code> 的細節，留著下篇解釋，可以參考 Reference 1, 2</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener">https://golang.org/ref/spec#Method_sets</a></li>
<li><a href="https://stackoverflow.com/questions/33587227/method-sets-pointer-vs-value-receiver" target="_blank" rel="noopener">https://stackoverflow.com/questions/33587227/method-sets-pointer-vs-value-receiver</a></li>
</ol>
]]></content>
      <categories>
        <category>golang78 syntax series</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
